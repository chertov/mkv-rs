/// The code was generated by codegen!

use std::collections::VecDeque;

use super::io::*;
use super::structs::*;
use super::ids::EbmlId;
use super::{Ebml, ElementSize};

impl<R: std::io::Read> super::ElementReadBlocking<R> for EbmlHeader {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::EbmlHeader { return Err(anyhow::anyhow!("EbmlHeader not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'EbmlHeader' unknown data size is not allowed")),
        };
        let mut version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut read_version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut doc_type: VecDeque<Ebml<String>> = VecDeque::new();
        let mut doc_type_version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut doc_type_read_version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut doc_type_extension: VecDeque<Ebml<DocTypeExtension>> = VecDeque::new();
        let mut doc_type_extension_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut doc_type_extension_version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut ebml_max_id_length: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut ebml_max_size_length: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::Version => {
                    let size = size.try_sized(EbmlId::Version)?;
                    version.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ReadVersion => {
                    let size = size.try_sized(EbmlId::ReadVersion)?;
                    read_version.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DocType => {
                    let size = size.try_sized(EbmlId::DocType)?;
                    doc_type.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DocTypeVersion => {
                    let size = size.try_sized(EbmlId::DocTypeVersion)?;
                    doc_type_version.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DocTypeReadVersion => {
                    let size = size.try_sized(EbmlId::DocTypeReadVersion)?;
                    doc_type_read_version.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DocTypeExtension => {
                    let (val, read) = DocTypeExtension::read_body(r, size)?;
                    doc_type_extension.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::DocTypeExtensionName => {
                    let size = size.try_sized(EbmlId::DocTypeExtensionName)?;
                    doc_type_extension_name.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DocTypeExtensionVersion => {
                    let size = size.try_sized(EbmlId::DocTypeExtensionVersion)?;
                    doc_type_extension_version.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::EbmlMaxIdLength => {
                    let size = size.try_sized(EbmlId::EbmlMaxIdLength)?;
                    ebml_max_id_length.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::EbmlMaxSizeLength => {
                    let size = size.try_sized(EbmlId::EbmlMaxSizeLength)?;
                    ebml_max_size_length.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'EbmlHeader'", id))?,
            }
            index += 1;
        }

        if version.len() != 1 { Err(anyhow::anyhow!("One element 'Version' must be in 'EbmlHeader'. Found {}", version.len()))? }
        let version = version.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Version' doesn't exist in 'EbmlHeader'"))?;
        if read_version.len() != 1 { Err(anyhow::anyhow!("One element 'ReadVersion' must be in 'EbmlHeader'. Found {}", read_version.len()))? }
        let read_version = read_version.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ReadVersion' doesn't exist in 'EbmlHeader'"))?;
        if doc_type.len() != 1 { Err(anyhow::anyhow!("One element 'DocType' must be in 'EbmlHeader'. Found {}", doc_type.len()))? }
        let doc_type = doc_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'DocType' doesn't exist in 'EbmlHeader'"))?;
        if doc_type_version.len() != 1 { Err(anyhow::anyhow!("One element 'DocTypeVersion' must be in 'EbmlHeader'. Found {}", doc_type_version.len()))? }
        let doc_type_version = doc_type_version.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'DocTypeVersion' doesn't exist in 'EbmlHeader'"))?;
        if doc_type_read_version.len() != 1 { Err(anyhow::anyhow!("One element 'DocTypeReadVersion' must be in 'EbmlHeader'. Found {}", doc_type_read_version.len()))? }
        let doc_type_read_version = doc_type_read_version.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'DocTypeReadVersion' doesn't exist in 'EbmlHeader'"))?;
        if doc_type_extension.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DocTypeExtension' in 'EbmlHeader' possible. Found {}", doc_type_extension.len()))? }
        let doc_type_extension = doc_type_extension.pop_front();
        if doc_type_extension_name.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DocTypeExtensionName' in 'EbmlHeader' possible. Found {}", doc_type_extension_name.len()))? }
        let doc_type_extension_name = doc_type_extension_name.pop_front();
        if doc_type_extension_version.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DocTypeExtensionVersion' in 'EbmlHeader' possible. Found {}", doc_type_extension_version.len()))? }
        let doc_type_extension_version = doc_type_extension_version.pop_front();
        if ebml_max_id_length.len() == 0 { ebml_max_id_length.push_back(Ebml::new(4)); }
        if ebml_max_id_length.len() != 1 { Err(anyhow::anyhow!("One element 'EbmlMaxIdLength' must be in 'EbmlHeader'. Found {}", ebml_max_id_length.len()))? }
        let ebml_max_id_length = ebml_max_id_length.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EbmlMaxIdLength' doesn't exist in 'EbmlHeader'"))?;
        if ebml_max_size_length.len() == 0 { ebml_max_size_length.push_back(Ebml::new(8)); }
        if ebml_max_size_length.len() != 1 { Err(anyhow::anyhow!("One element 'EbmlMaxSizeLength' must be in 'EbmlHeader'. Found {}", ebml_max_size_length.len()))? }
        let ebml_max_size_length = ebml_max_size_length.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EbmlMaxSizeLength' doesn't exist in 'EbmlHeader'"))?;

        Ok((Self{
            size,

            version,
            read_version,
            doc_type,
            doc_type_version,
            doc_type_read_version,
            doc_type_extension,
            doc_type_extension_name,
            doc_type_extension_version,
            ebml_max_id_length,
            ebml_max_size_length,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for EbmlHeader {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::EbmlHeader { return Err(anyhow::anyhow!("EbmlHeader not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'EbmlHeader' unknown data size is not allowed")),
        };
        let mut version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut read_version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut doc_type: VecDeque<Ebml<String>> = VecDeque::new();
        let mut doc_type_version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut doc_type_read_version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut doc_type_extension: VecDeque<Ebml<DocTypeExtension>> = VecDeque::new();
        let mut doc_type_extension_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut doc_type_extension_version: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut ebml_max_id_length: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut ebml_max_size_length: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::Version => {
                    let size = size.try_sized(EbmlId::Version)?;
                    version.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ReadVersion => {
                    let size = size.try_sized(EbmlId::ReadVersion)?;
                    read_version.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DocType => {
                    let size = size.try_sized(EbmlId::DocType)?;
                    doc_type.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DocTypeVersion => {
                    let size = size.try_sized(EbmlId::DocTypeVersion)?;
                    doc_type_version.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DocTypeReadVersion => {
                    let size = size.try_sized(EbmlId::DocTypeReadVersion)?;
                    doc_type_read_version.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DocTypeExtension => {
                    let (val, read) = DocTypeExtension::read_body(r, size).await?;
                    doc_type_extension.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::DocTypeExtensionName => {
                    let size = size.try_sized(EbmlId::DocTypeExtensionName)?;
                    doc_type_extension_name.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DocTypeExtensionVersion => {
                    let size = size.try_sized(EbmlId::DocTypeExtensionVersion)?;
                    doc_type_extension_version.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::EbmlMaxIdLength => {
                    let size = size.try_sized(EbmlId::EbmlMaxIdLength)?;
                    ebml_max_id_length.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::EbmlMaxSizeLength => {
                    let size = size.try_sized(EbmlId::EbmlMaxSizeLength)?;
                    ebml_max_size_length.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'EbmlHeader'", id))?,
            }
            index += 1;
        }

        if version.len() != 1 { Err(anyhow::anyhow!("One element 'Version' must be in 'EbmlHeader'. Found {}", version.len()))? }
        let version = version.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Version' doesn't exist in 'EbmlHeader'"))?;
        if read_version.len() != 1 { Err(anyhow::anyhow!("One element 'ReadVersion' must be in 'EbmlHeader'. Found {}", read_version.len()))? }
        let read_version = read_version.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ReadVersion' doesn't exist in 'EbmlHeader'"))?;
        if doc_type.len() != 1 { Err(anyhow::anyhow!("One element 'DocType' must be in 'EbmlHeader'. Found {}", doc_type.len()))? }
        let doc_type = doc_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'DocType' doesn't exist in 'EbmlHeader'"))?;
        if doc_type_version.len() != 1 { Err(anyhow::anyhow!("One element 'DocTypeVersion' must be in 'EbmlHeader'. Found {}", doc_type_version.len()))? }
        let doc_type_version = doc_type_version.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'DocTypeVersion' doesn't exist in 'EbmlHeader'"))?;
        if doc_type_read_version.len() != 1 { Err(anyhow::anyhow!("One element 'DocTypeReadVersion' must be in 'EbmlHeader'. Found {}", doc_type_read_version.len()))? }
        let doc_type_read_version = doc_type_read_version.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'DocTypeReadVersion' doesn't exist in 'EbmlHeader'"))?;
        if doc_type_extension.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DocTypeExtension' in 'EbmlHeader' possible. Found {}", doc_type_extension.len()))? }
        let doc_type_extension = doc_type_extension.pop_front();
        if doc_type_extension_name.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DocTypeExtensionName' in 'EbmlHeader' possible. Found {}", doc_type_extension_name.len()))? }
        let doc_type_extension_name = doc_type_extension_name.pop_front();
        if doc_type_extension_version.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DocTypeExtensionVersion' in 'EbmlHeader' possible. Found {}", doc_type_extension_version.len()))? }
        let doc_type_extension_version = doc_type_extension_version.pop_front();
        if ebml_max_id_length.len() == 0 { ebml_max_id_length.push_back(Ebml::new(4)); }
        if ebml_max_id_length.len() != 1 { Err(anyhow::anyhow!("One element 'EbmlMaxIdLength' must be in 'EbmlHeader'. Found {}", ebml_max_id_length.len()))? }
        let ebml_max_id_length = ebml_max_id_length.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EbmlMaxIdLength' doesn't exist in 'EbmlHeader'"))?;
        if ebml_max_size_length.len() == 0 { ebml_max_size_length.push_back(Ebml::new(8)); }
        if ebml_max_size_length.len() != 1 { Err(anyhow::anyhow!("One element 'EbmlMaxSizeLength' must be in 'EbmlHeader'. Found {}", ebml_max_size_length.len()))? }
        let ebml_max_size_length = ebml_max_size_length.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EbmlMaxSizeLength' doesn't exist in 'EbmlHeader'"))?;

        Ok((Self{
            size,

            version,
            read_version,
            doc_type,
            doc_type_version,
            doc_type_read_version,
            doc_type_extension,
            doc_type_extension_name,
            doc_type_extension_version,
            ebml_max_id_length,
            ebml_max_size_length,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for DocTypeExtension {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::DocTypeExtension { return Err(anyhow::anyhow!("DocTypeExtension not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'DocTypeExtension' unknown data size is not allowed")),
        };

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'DocTypeExtension'", id))?,
            }
            index += 1;
        }


        Ok((Self{
            size,

        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for DocTypeExtension {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::DocTypeExtension { return Err(anyhow::anyhow!("DocTypeExtension not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'DocTypeExtension' unknown data size is not allowed")),
        };

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'DocTypeExtension'", id))?,
            }
            index += 1;
        }


        Ok((Self{
            size,

        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Segment {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Segment { return Err(anyhow::anyhow!("Segment not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let mut void: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut crc_32: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut seek_head: VecDeque<Ebml<SeekHead>> = VecDeque::new();
        let mut info: VecDeque<Ebml<Info>> = VecDeque::new();
        let mut cluster: VecDeque<Ebml<Cluster>> = VecDeque::new();
        let mut tracks: VecDeque<Ebml<Tracks>> = VecDeque::new();
        let mut cues: VecDeque<Ebml<Cues>> = VecDeque::new();
        let mut attachments: VecDeque<Ebml<Attachments>> = VecDeque::new();
        let mut chapters: VecDeque<Ebml<Chapters>> = VecDeque::new();
        let mut tags: VecDeque<Ebml<Tags>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if let ElementSize::Sized(size) = size { if all_size >= size as usize { break } }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            if let ElementSize::Unknown(_) = size { if id == EbmlId::Segment  { break } }
            match id {
                EbmlId::Void => {
                    let size = size.try_sized(EbmlId::Void)?;
                    void.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Crc32 => {
                    let size = size.try_sized(EbmlId::Crc32)?;
                    crc_32.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::SeekHead => {
                    let (val, read) = SeekHead::read_body(r, size)?;
                    seek_head.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Info => {
                    let (val, read) = Info::read_body(r, size)?;
                    info.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Cluster => {
                    let (val, read) = Cluster::read_body(r, size)?; all_size += read;
                    cluster.push_back(Ebml::new_index(index, val));
                },
                EbmlId::Tracks => {
                    let (val, read) = Tracks::read_body(r, size)?;
                    tracks.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Cues => {
                    let (val, read) = Cues::read_body(r, size)?;
                    cues.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Attachments => {
                    let (val, read) = Attachments::read_body(r, size)?;
                    attachments.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Chapters => {
                    let (val, read) = Chapters::read_body(r, size)?;
                    chapters.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Tags => {
                    let (val, read) = Tags::read_body(r, size)?;
                    tags.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Segment'", id))?,
            }
            index += 1;
        }

        let void = Vec::from(void);
        if crc_32.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Crc32' in 'Segment' possible. Found {}", crc_32.len()))? }
        let crc_32 = crc_32.pop_front();
        let seek_head = Vec::from(seek_head);
        if info.len() != 1 { Err(anyhow::anyhow!("One element 'Info' must be in 'Segment'. Found {}", info.len()))? }
        let info = info.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Info' doesn't exist in 'Segment'"))?;
        let cluster = Vec::from(cluster);
        if tracks.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Tracks' in 'Segment' possible. Found {}", tracks.len()))? }
        let tracks = tracks.pop_front();
        if cues.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Cues' in 'Segment' possible. Found {}", cues.len()))? }
        let cues = cues.pop_front();
        if attachments.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Attachments' in 'Segment' possible. Found {}", attachments.len()))? }
        let attachments = attachments.pop_front();
        if chapters.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Chapters' in 'Segment' possible. Found {}", chapters.len()))? }
        let chapters = chapters.pop_front();
        let tags = Vec::from(tags);

        Ok((Self{
            size,

            void,
            crc_32,
            seek_head,
            info,
            cluster,
            tracks,
            cues,
            attachments,
            chapters,
            tags,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Segment {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Segment { return Err(anyhow::anyhow!("Segment not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let mut void: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut crc_32: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut seek_head: VecDeque<Ebml<SeekHead>> = VecDeque::new();
        let mut info: VecDeque<Ebml<Info>> = VecDeque::new();
        let mut cluster: VecDeque<Ebml<Cluster>> = VecDeque::new();
        let mut tracks: VecDeque<Ebml<Tracks>> = VecDeque::new();
        let mut cues: VecDeque<Ebml<Cues>> = VecDeque::new();
        let mut attachments: VecDeque<Ebml<Attachments>> = VecDeque::new();
        let mut chapters: VecDeque<Ebml<Chapters>> = VecDeque::new();
        let mut tags: VecDeque<Ebml<Tags>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if let ElementSize::Sized(size) = size { if all_size >= size as usize { break } }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            if let ElementSize::Unknown(_) = size { if id == EbmlId::Segment  { break } }
            match id {
                EbmlId::Void => {
                    let size = size.try_sized(EbmlId::Void)?;
                    void.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Crc32 => {
                    let size = size.try_sized(EbmlId::Crc32)?;
                    crc_32.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::SeekHead => {
                    let (val, read) = SeekHead::read_body(r, size).await?;
                    seek_head.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Info => {
                    let (val, read) = Info::read_body(r, size).await?;
                    info.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Cluster => {
                    let (val, read) = Cluster::read_body(r, size).await?; all_size += read;
                    cluster.push_back(Ebml::new_index(index, val));
                },
                EbmlId::Tracks => {
                    let (val, read) = Tracks::read_body(r, size).await?;
                    tracks.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Cues => {
                    let (val, read) = Cues::read_body(r, size).await?;
                    cues.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Attachments => {
                    let (val, read) = Attachments::read_body(r, size).await?;
                    attachments.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Chapters => {
                    let (val, read) = Chapters::read_body(r, size).await?;
                    chapters.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Tags => {
                    let (val, read) = Tags::read_body(r, size).await?;
                    tags.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Segment'", id))?,
            }
            index += 1;
        }

        let void = Vec::from(void);
        if crc_32.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Crc32' in 'Segment' possible. Found {}", crc_32.len()))? }
        let crc_32 = crc_32.pop_front();
        let seek_head = Vec::from(seek_head);
        if info.len() != 1 { Err(anyhow::anyhow!("One element 'Info' must be in 'Segment'. Found {}", info.len()))? }
        let info = info.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Info' doesn't exist in 'Segment'"))?;
        let cluster = Vec::from(cluster);
        if tracks.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Tracks' in 'Segment' possible. Found {}", tracks.len()))? }
        let tracks = tracks.pop_front();
        if cues.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Cues' in 'Segment' possible. Found {}", cues.len()))? }
        let cues = cues.pop_front();
        if attachments.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Attachments' in 'Segment' possible. Found {}", attachments.len()))? }
        let attachments = attachments.pop_front();
        if chapters.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Chapters' in 'Segment' possible. Found {}", chapters.len()))? }
        let chapters = chapters.pop_front();
        let tags = Vec::from(tags);

        Ok((Self{
            size,

            void,
            crc_32,
            seek_head,
            info,
            cluster,
            tracks,
            cues,
            attachments,
            chapters,
            tags,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for SeekHead {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::SeekHead { return Err(anyhow::anyhow!("SeekHead not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'SeekHead' unknown data size is not allowed")),
        };
        let mut seek: VecDeque<Ebml<Seek>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::Seek => {
                    let (val, read) = Seek::read_body(r, size)?;
                    seek.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'SeekHead'", id))?,
            }
            index += 1;
        }

        let seek = Vec::from(seek);

        Ok((Self{
            size,

            seek,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for SeekHead {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::SeekHead { return Err(anyhow::anyhow!("SeekHead not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'SeekHead' unknown data size is not allowed")),
        };
        let mut seek: VecDeque<Ebml<Seek>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::Seek => {
                    let (val, read) = Seek::read_body(r, size).await?;
                    seek.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'SeekHead'", id))?,
            }
            index += 1;
        }

        let seek = Vec::from(seek);

        Ok((Self{
            size,

            seek,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Seek {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Seek { return Err(anyhow::anyhow!("Seek not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Seek' unknown data size is not allowed")),
        };
        let mut seek_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut seek_position: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::SeekId => {
                    let size = size.try_sized(EbmlId::SeekId)?;
                    seek_id.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::SeekPosition => {
                    let size = size.try_sized(EbmlId::SeekPosition)?;
                    seek_position.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Seek'", id))?,
            }
            index += 1;
        }

        if seek_id.len() != 1 { Err(anyhow::anyhow!("One element 'SeekId' must be in 'Seek'. Found {}", seek_id.len()))? }
        let seek_id = seek_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'SeekId' doesn't exist in 'Seek'"))?;
        if seek_position.len() != 1 { Err(anyhow::anyhow!("One element 'SeekPosition' must be in 'Seek'. Found {}", seek_position.len()))? }
        let seek_position = seek_position.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'SeekPosition' doesn't exist in 'Seek'"))?;

        Ok((Self{
            size,

            seek_id,
            seek_position,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Seek {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Seek { return Err(anyhow::anyhow!("Seek not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Seek' unknown data size is not allowed")),
        };
        let mut seek_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut seek_position: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::SeekId => {
                    let size = size.try_sized(EbmlId::SeekId)?;
                    seek_id.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::SeekPosition => {
                    let size = size.try_sized(EbmlId::SeekPosition)?;
                    seek_position.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Seek'", id))?,
            }
            index += 1;
        }

        if seek_id.len() != 1 { Err(anyhow::anyhow!("One element 'SeekId' must be in 'Seek'. Found {}", seek_id.len()))? }
        let seek_id = seek_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'SeekId' doesn't exist in 'Seek'"))?;
        if seek_position.len() != 1 { Err(anyhow::anyhow!("One element 'SeekPosition' must be in 'Seek'. Found {}", seek_position.len()))? }
        let seek_position = seek_position.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'SeekPosition' doesn't exist in 'Seek'"))?;

        Ok((Self{
            size,

            seek_id,
            seek_position,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Info {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Info { return Err(anyhow::anyhow!("Info not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Info' unknown data size is not allowed")),
        };
        let mut segment_uuid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut segment_filename: VecDeque<Ebml<String>> = VecDeque::new();
        let mut prev_uuid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut prev_filename: VecDeque<Ebml<String>> = VecDeque::new();
        let mut next_uuid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut next_filename: VecDeque<Ebml<String>> = VecDeque::new();
        let mut segment_family: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut chapter_translate: VecDeque<Ebml<ChapterTranslate>> = VecDeque::new();
        let mut timestamp_scale: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut duration: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut date_utc: VecDeque<Ebml<time::OffsetDateTime>> = VecDeque::new();
        let mut title: VecDeque<Ebml<String>> = VecDeque::new();
        let mut muxing_app: VecDeque<Ebml<String>> = VecDeque::new();
        let mut writing_app: VecDeque<Ebml<String>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::SegmentUuid => {
                    let size = size.try_sized(EbmlId::SegmentUuid)?;
                    segment_uuid.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::SegmentFilename => {
                    let size = size.try_sized(EbmlId::SegmentFilename)?;
                    segment_filename.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PrevUuid => {
                    let size = size.try_sized(EbmlId::PrevUuid)?;
                    prev_uuid.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PrevFilename => {
                    let size = size.try_sized(EbmlId::PrevFilename)?;
                    prev_filename.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::NextUuid => {
                    let size = size.try_sized(EbmlId::NextUuid)?;
                    next_uuid.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::NextFilename => {
                    let size = size.try_sized(EbmlId::NextFilename)?;
                    next_filename.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::SegmentFamily => {
                    let size = size.try_sized(EbmlId::SegmentFamily)?;
                    segment_family.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTranslate => {
                    let (val, read) = ChapterTranslate::read_body(r, size)?;
                    chapter_translate.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::TimestampScale => {
                    let size = size.try_sized(EbmlId::TimestampScale)?;
                    timestamp_scale.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Duration => {
                    let size = size.try_sized(EbmlId::Duration)?;
                    duration.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DateUtc => {
                    let size = size.try_sized(EbmlId::DateUtc)?;
                    date_utc.push_back(Ebml::new_index(index, blocking::read_date(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Title => {
                    let size = size.try_sized(EbmlId::Title)?;
                    title.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::MuxingApp => {
                    let size = size.try_sized(EbmlId::MuxingApp)?;
                    muxing_app.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::WritingApp => {
                    let size = size.try_sized(EbmlId::WritingApp)?;
                    writing_app.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Info'", id))?,
            }
            index += 1;
        }

        if segment_uuid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'SegmentUuid' in 'Info' possible. Found {}", segment_uuid.len()))? }
        let segment_uuid = segment_uuid.pop_front();
        if segment_filename.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'SegmentFilename' in 'Info' possible. Found {}", segment_filename.len()))? }
        let segment_filename = segment_filename.pop_front();
        if prev_uuid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrevUuid' in 'Info' possible. Found {}", prev_uuid.len()))? }
        let prev_uuid = prev_uuid.pop_front();
        if prev_filename.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrevFilename' in 'Info' possible. Found {}", prev_filename.len()))? }
        let prev_filename = prev_filename.pop_front();
        if next_uuid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'NextUuid' in 'Info' possible. Found {}", next_uuid.len()))? }
        let next_uuid = next_uuid.pop_front();
        if next_filename.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'NextFilename' in 'Info' possible. Found {}", next_filename.len()))? }
        let next_filename = next_filename.pop_front();
        let segment_family = Vec::from(segment_family);
        let chapter_translate = Vec::from(chapter_translate);
        if timestamp_scale.len() == 0 { timestamp_scale.push_back(Ebml::new(1000000)); }
        if timestamp_scale.len() != 1 { Err(anyhow::anyhow!("One element 'TimestampScale' must be in 'Info'. Found {}", timestamp_scale.len()))? }
        let timestamp_scale = timestamp_scale.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TimestampScale' doesn't exist in 'Info'"))?;
        if duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Duration' in 'Info' possible. Found {}", duration.len()))? }
        let duration = duration.pop_front();
        if date_utc.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DateUtc' in 'Info' possible. Found {}", date_utc.len()))? }
        let date_utc = date_utc.pop_front();
        if title.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Title' in 'Info' possible. Found {}", title.len()))? }
        let title = title.pop_front();
        if muxing_app.len() != 1 { Err(anyhow::anyhow!("One element 'MuxingApp' must be in 'Info'. Found {}", muxing_app.len()))? }
        let muxing_app = muxing_app.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'MuxingApp' doesn't exist in 'Info'"))?;
        if writing_app.len() != 1 { Err(anyhow::anyhow!("One element 'WritingApp' must be in 'Info'. Found {}", writing_app.len()))? }
        let writing_app = writing_app.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'WritingApp' doesn't exist in 'Info'"))?;

        Ok((Self{
            size,

            segment_uuid,
            segment_filename,
            prev_uuid,
            prev_filename,
            next_uuid,
            next_filename,
            segment_family,
            chapter_translate,
            timestamp_scale,
            duration,
            date_utc,
            title,
            muxing_app,
            writing_app,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Info {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Info { return Err(anyhow::anyhow!("Info not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Info' unknown data size is not allowed")),
        };
        let mut segment_uuid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut segment_filename: VecDeque<Ebml<String>> = VecDeque::new();
        let mut prev_uuid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut prev_filename: VecDeque<Ebml<String>> = VecDeque::new();
        let mut next_uuid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut next_filename: VecDeque<Ebml<String>> = VecDeque::new();
        let mut segment_family: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut chapter_translate: VecDeque<Ebml<ChapterTranslate>> = VecDeque::new();
        let mut timestamp_scale: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut duration: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut date_utc: VecDeque<Ebml<time::OffsetDateTime>> = VecDeque::new();
        let mut title: VecDeque<Ebml<String>> = VecDeque::new();
        let mut muxing_app: VecDeque<Ebml<String>> = VecDeque::new();
        let mut writing_app: VecDeque<Ebml<String>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::SegmentUuid => {
                    let size = size.try_sized(EbmlId::SegmentUuid)?;
                    segment_uuid.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::SegmentFilename => {
                    let size = size.try_sized(EbmlId::SegmentFilename)?;
                    segment_filename.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PrevUuid => {
                    let size = size.try_sized(EbmlId::PrevUuid)?;
                    prev_uuid.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PrevFilename => {
                    let size = size.try_sized(EbmlId::PrevFilename)?;
                    prev_filename.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::NextUuid => {
                    let size = size.try_sized(EbmlId::NextUuid)?;
                    next_uuid.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::NextFilename => {
                    let size = size.try_sized(EbmlId::NextFilename)?;
                    next_filename.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::SegmentFamily => {
                    let size = size.try_sized(EbmlId::SegmentFamily)?;
                    segment_family.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTranslate => {
                    let (val, read) = ChapterTranslate::read_body(r, size).await?;
                    chapter_translate.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::TimestampScale => {
                    let size = size.try_sized(EbmlId::TimestampScale)?;
                    timestamp_scale.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Duration => {
                    let size = size.try_sized(EbmlId::Duration)?;
                    duration.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DateUtc => {
                    let size = size.try_sized(EbmlId::DateUtc)?;
                    date_utc.push_back(Ebml::new_index(index, async_::read_date(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Title => {
                    let size = size.try_sized(EbmlId::Title)?;
                    title.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::MuxingApp => {
                    let size = size.try_sized(EbmlId::MuxingApp)?;
                    muxing_app.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::WritingApp => {
                    let size = size.try_sized(EbmlId::WritingApp)?;
                    writing_app.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Info'", id))?,
            }
            index += 1;
        }

        if segment_uuid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'SegmentUuid' in 'Info' possible. Found {}", segment_uuid.len()))? }
        let segment_uuid = segment_uuid.pop_front();
        if segment_filename.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'SegmentFilename' in 'Info' possible. Found {}", segment_filename.len()))? }
        let segment_filename = segment_filename.pop_front();
        if prev_uuid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrevUuid' in 'Info' possible. Found {}", prev_uuid.len()))? }
        let prev_uuid = prev_uuid.pop_front();
        if prev_filename.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrevFilename' in 'Info' possible. Found {}", prev_filename.len()))? }
        let prev_filename = prev_filename.pop_front();
        if next_uuid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'NextUuid' in 'Info' possible. Found {}", next_uuid.len()))? }
        let next_uuid = next_uuid.pop_front();
        if next_filename.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'NextFilename' in 'Info' possible. Found {}", next_filename.len()))? }
        let next_filename = next_filename.pop_front();
        let segment_family = Vec::from(segment_family);
        let chapter_translate = Vec::from(chapter_translate);
        if timestamp_scale.len() == 0 { timestamp_scale.push_back(Ebml::new(1000000)); }
        if timestamp_scale.len() != 1 { Err(anyhow::anyhow!("One element 'TimestampScale' must be in 'Info'. Found {}", timestamp_scale.len()))? }
        let timestamp_scale = timestamp_scale.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TimestampScale' doesn't exist in 'Info'"))?;
        if duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Duration' in 'Info' possible. Found {}", duration.len()))? }
        let duration = duration.pop_front();
        if date_utc.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DateUtc' in 'Info' possible. Found {}", date_utc.len()))? }
        let date_utc = date_utc.pop_front();
        if title.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Title' in 'Info' possible. Found {}", title.len()))? }
        let title = title.pop_front();
        if muxing_app.len() != 1 { Err(anyhow::anyhow!("One element 'MuxingApp' must be in 'Info'. Found {}", muxing_app.len()))? }
        let muxing_app = muxing_app.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'MuxingApp' doesn't exist in 'Info'"))?;
        if writing_app.len() != 1 { Err(anyhow::anyhow!("One element 'WritingApp' must be in 'Info'. Found {}", writing_app.len()))? }
        let writing_app = writing_app.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'WritingApp' doesn't exist in 'Info'"))?;

        Ok((Self{
            size,

            segment_uuid,
            segment_filename,
            prev_uuid,
            prev_filename,
            next_uuid,
            next_filename,
            segment_family,
            chapter_translate,
            timestamp_scale,
            duration,
            date_utc,
            title,
            muxing_app,
            writing_app,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ChapterTranslate {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ChapterTranslate { return Err(anyhow::anyhow!("ChapterTranslate not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapterTranslate' unknown data size is not allowed")),
        };
        let mut chapter_translate_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut chapter_translate_codec: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_translate_edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapterTranslateId => {
                    let size = size.try_sized(EbmlId::ChapterTranslateId)?;
                    chapter_translate_id.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTranslateCodec => {
                    let size = size.try_sized(EbmlId::ChapterTranslateCodec)?;
                    chapter_translate_codec.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTranslateEditionUid => {
                    let size = size.try_sized(EbmlId::ChapterTranslateEditionUid)?;
                    chapter_translate_edition_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapterTranslate'", id))?,
            }
            index += 1;
        }

        if chapter_translate_id.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterTranslateId' must be in 'ChapterTranslate'. Found {}", chapter_translate_id.len()))? }
        let chapter_translate_id = chapter_translate_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterTranslateId' doesn't exist in 'ChapterTranslate'"))?;
        if chapter_translate_codec.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterTranslateCodec' must be in 'ChapterTranslate'. Found {}", chapter_translate_codec.len()))? }
        let chapter_translate_codec = chapter_translate_codec.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterTranslateCodec' doesn't exist in 'ChapterTranslate'"))?;
        let chapter_translate_edition_uid = Vec::from(chapter_translate_edition_uid);

        Ok((Self{
            size,

            chapter_translate_id,
            chapter_translate_codec,
            chapter_translate_edition_uid,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ChapterTranslate {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ChapterTranslate { return Err(anyhow::anyhow!("ChapterTranslate not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapterTranslate' unknown data size is not allowed")),
        };
        let mut chapter_translate_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut chapter_translate_codec: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_translate_edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapterTranslateId => {
                    let size = size.try_sized(EbmlId::ChapterTranslateId)?;
                    chapter_translate_id.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTranslateCodec => {
                    let size = size.try_sized(EbmlId::ChapterTranslateCodec)?;
                    chapter_translate_codec.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTranslateEditionUid => {
                    let size = size.try_sized(EbmlId::ChapterTranslateEditionUid)?;
                    chapter_translate_edition_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapterTranslate'", id))?,
            }
            index += 1;
        }

        if chapter_translate_id.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterTranslateId' must be in 'ChapterTranslate'. Found {}", chapter_translate_id.len()))? }
        let chapter_translate_id = chapter_translate_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterTranslateId' doesn't exist in 'ChapterTranslate'"))?;
        if chapter_translate_codec.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterTranslateCodec' must be in 'ChapterTranslate'. Found {}", chapter_translate_codec.len()))? }
        let chapter_translate_codec = chapter_translate_codec.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterTranslateCodec' doesn't exist in 'ChapterTranslate'"))?;
        let chapter_translate_edition_uid = Vec::from(chapter_translate_edition_uid);

        Ok((Self{
            size,

            chapter_translate_id,
            chapter_translate_codec,
            chapter_translate_edition_uid,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Cluster {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Cluster { return Err(anyhow::anyhow!("Cluster not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let mut timestamp: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut silent_tracks: VecDeque<Ebml<SilentTracks>> = VecDeque::new();
        let mut position: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut prev_size: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut simple_block: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut block_group: VecDeque<Ebml<BlockGroup>> = VecDeque::new();
        let mut encrypted_block: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if let ElementSize::Sized(size) = size { if all_size >= size as usize { break } }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            if let ElementSize::Unknown(_) = size { if id == EbmlId::Cluster  { break } }
            match id {
                EbmlId::Timestamp => {
                    let size = size.try_sized(EbmlId::Timestamp)?;
                    timestamp.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::SilentTracks => {
                    let (val, read) = SilentTracks::read_body(r, size)?;
                    silent_tracks.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Position => {
                    let size = size.try_sized(EbmlId::Position)?;
                    position.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PrevSize => {
                    let size = size.try_sized(EbmlId::PrevSize)?;
                    prev_size.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::SimpleBlock => {
                    let size = size.try_sized(EbmlId::SimpleBlock)?;
                    simple_block.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockGroup => {
                    let (val, read) = BlockGroup::read_body(r, size)?;
                    block_group.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::EncryptedBlock => {
                    let size = size.try_sized(EbmlId::EncryptedBlock)?;
                    encrypted_block.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Cluster'", id))?,
            }
            index += 1;
        }

        if timestamp.len() != 1 { Err(anyhow::anyhow!("One element 'Timestamp' must be in 'Cluster'. Found {}", timestamp.len()))? }
        let timestamp = timestamp.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Timestamp' doesn't exist in 'Cluster'"))?;
        if silent_tracks.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'SilentTracks' in 'Cluster' possible. Found {}", silent_tracks.len()))? }
        let silent_tracks = silent_tracks.pop_front();
        if position.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Position' in 'Cluster' possible. Found {}", position.len()))? }
        let position = position.pop_front();
        if prev_size.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrevSize' in 'Cluster' possible. Found {}", prev_size.len()))? }
        let prev_size = prev_size.pop_front();
        let simple_block = Vec::from(simple_block);
        let block_group = Vec::from(block_group);
        let encrypted_block = Vec::from(encrypted_block);

        Ok((Self{
            size,

            timestamp,
            silent_tracks,
            position,
            prev_size,
            simple_block,
            block_group,
            encrypted_block,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Cluster {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Cluster { return Err(anyhow::anyhow!("Cluster not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let mut timestamp: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut silent_tracks: VecDeque<Ebml<SilentTracks>> = VecDeque::new();
        let mut position: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut prev_size: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut simple_block: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut block_group: VecDeque<Ebml<BlockGroup>> = VecDeque::new();
        let mut encrypted_block: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if let ElementSize::Sized(size) = size { if all_size >= size as usize { break } }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            if let ElementSize::Unknown(_) = size { if id == EbmlId::Cluster  { break } }
            match id {
                EbmlId::Timestamp => {
                    let size = size.try_sized(EbmlId::Timestamp)?;
                    timestamp.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::SilentTracks => {
                    let (val, read) = SilentTracks::read_body(r, size).await?;
                    silent_tracks.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Position => {
                    let size = size.try_sized(EbmlId::Position)?;
                    position.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PrevSize => {
                    let size = size.try_sized(EbmlId::PrevSize)?;
                    prev_size.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::SimpleBlock => {
                    let size = size.try_sized(EbmlId::SimpleBlock)?;
                    simple_block.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockGroup => {
                    let (val, read) = BlockGroup::read_body(r, size).await?;
                    block_group.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::EncryptedBlock => {
                    let size = size.try_sized(EbmlId::EncryptedBlock)?;
                    encrypted_block.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Cluster'", id))?,
            }
            index += 1;
        }

        if timestamp.len() != 1 { Err(anyhow::anyhow!("One element 'Timestamp' must be in 'Cluster'. Found {}", timestamp.len()))? }
        let timestamp = timestamp.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Timestamp' doesn't exist in 'Cluster'"))?;
        if silent_tracks.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'SilentTracks' in 'Cluster' possible. Found {}", silent_tracks.len()))? }
        let silent_tracks = silent_tracks.pop_front();
        if position.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Position' in 'Cluster' possible. Found {}", position.len()))? }
        let position = position.pop_front();
        if prev_size.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrevSize' in 'Cluster' possible. Found {}", prev_size.len()))? }
        let prev_size = prev_size.pop_front();
        let simple_block = Vec::from(simple_block);
        let block_group = Vec::from(block_group);
        let encrypted_block = Vec::from(encrypted_block);

        Ok((Self{
            size,

            timestamp,
            silent_tracks,
            position,
            prev_size,
            simple_block,
            block_group,
            encrypted_block,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for SilentTracks {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::SilentTracks { return Err(anyhow::anyhow!("SilentTracks not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'SilentTracks' unknown data size is not allowed")),
        };
        let mut silent_track_number: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::SilentTrackNumber => {
                    let size = size.try_sized(EbmlId::SilentTrackNumber)?;
                    silent_track_number.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'SilentTracks'", id))?,
            }
            index += 1;
        }

        let silent_track_number = Vec::from(silent_track_number);

        Ok((Self{
            size,

            silent_track_number,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for SilentTracks {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::SilentTracks { return Err(anyhow::anyhow!("SilentTracks not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'SilentTracks' unknown data size is not allowed")),
        };
        let mut silent_track_number: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::SilentTrackNumber => {
                    let size = size.try_sized(EbmlId::SilentTrackNumber)?;
                    silent_track_number.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'SilentTracks'", id))?,
            }
            index += 1;
        }

        let silent_track_number = Vec::from(silent_track_number);

        Ok((Self{
            size,

            silent_track_number,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for BlockGroup {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::BlockGroup { return Err(anyhow::anyhow!("BlockGroup not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'BlockGroup' unknown data size is not allowed")),
        };
        let mut block: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut block_virtual: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut block_additions: VecDeque<Ebml<BlockAdditions>> = VecDeque::new();
        let mut block_duration: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut reference_priority: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut reference_block: VecDeque<Ebml<i64>> = VecDeque::new();
        let mut reference_virtual: VecDeque<Ebml<i64>> = VecDeque::new();
        let mut codec_state: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut discard_padding: VecDeque<Ebml<i64>> = VecDeque::new();
        let mut slices: VecDeque<Ebml<Slices>> = VecDeque::new();
        let mut reference_frame: VecDeque<Ebml<ReferenceFrame>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::Block => {
                    let size = size.try_sized(EbmlId::Block)?;
                    block.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockVirtual => {
                    let size = size.try_sized(EbmlId::BlockVirtual)?;
                    block_virtual.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockAdditions => {
                    let (val, read) = BlockAdditions::read_body(r, size)?;
                    block_additions.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::BlockDuration => {
                    let size = size.try_sized(EbmlId::BlockDuration)?;
                    block_duration.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ReferencePriority => {
                    let size = size.try_sized(EbmlId::ReferencePriority)?;
                    reference_priority.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ReferenceBlock => {
                    let size = size.try_sized(EbmlId::ReferenceBlock)?;
                    reference_block.push_back(Ebml::new_index(index, blocking::read_int(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ReferenceVirtual => {
                    let size = size.try_sized(EbmlId::ReferenceVirtual)?;
                    reference_virtual.push_back(Ebml::new_index(index, blocking::read_int(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecState => {
                    let size = size.try_sized(EbmlId::CodecState)?;
                    codec_state.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DiscardPadding => {
                    let size = size.try_sized(EbmlId::DiscardPadding)?;
                    discard_padding.push_back(Ebml::new_index(index, blocking::read_int(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Slices => {
                    let (val, read) = Slices::read_body(r, size)?;
                    slices.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ReferenceFrame => {
                    let (val, read) = ReferenceFrame::read_body(r, size)?;
                    reference_frame.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'BlockGroup'", id))?,
            }
            index += 1;
        }

        if block.len() != 1 { Err(anyhow::anyhow!("One element 'Block' must be in 'BlockGroup'. Found {}", block.len()))? }
        let block = block.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Block' doesn't exist in 'BlockGroup'"))?;
        if block_virtual.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockVirtual' in 'BlockGroup' possible. Found {}", block_virtual.len()))? }
        let block_virtual = block_virtual.pop_front();
        if block_additions.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAdditions' in 'BlockGroup' possible. Found {}", block_additions.len()))? }
        let block_additions = block_additions.pop_front();
        if block_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockDuration' in 'BlockGroup' possible. Found {}", block_duration.len()))? }
        let block_duration = block_duration.pop_front();
        if reference_priority.len() == 0 { reference_priority.push_back(Ebml::new(0)); }
        if reference_priority.len() != 1 { Err(anyhow::anyhow!("One element 'ReferencePriority' must be in 'BlockGroup'. Found {}", reference_priority.len()))? }
        let reference_priority = reference_priority.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ReferencePriority' doesn't exist in 'BlockGroup'"))?;
        let reference_block = Vec::from(reference_block);
        if reference_virtual.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ReferenceVirtual' in 'BlockGroup' possible. Found {}", reference_virtual.len()))? }
        let reference_virtual = reference_virtual.pop_front();
        if codec_state.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CodecState' in 'BlockGroup' possible. Found {}", codec_state.len()))? }
        let codec_state = codec_state.pop_front();
        if discard_padding.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DiscardPadding' in 'BlockGroup' possible. Found {}", discard_padding.len()))? }
        let discard_padding = discard_padding.pop_front();
        if slices.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Slices' in 'BlockGroup' possible. Found {}", slices.len()))? }
        let slices = slices.pop_front();
        if reference_frame.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ReferenceFrame' in 'BlockGroup' possible. Found {}", reference_frame.len()))? }
        let reference_frame = reference_frame.pop_front();

        Ok((Self{
            size,

            block,
            block_virtual,
            block_additions,
            block_duration,
            reference_priority,
            reference_block,
            reference_virtual,
            codec_state,
            discard_padding,
            slices,
            reference_frame,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for BlockGroup {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::BlockGroup { return Err(anyhow::anyhow!("BlockGroup not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'BlockGroup' unknown data size is not allowed")),
        };
        let mut block: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut block_virtual: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut block_additions: VecDeque<Ebml<BlockAdditions>> = VecDeque::new();
        let mut block_duration: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut reference_priority: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut reference_block: VecDeque<Ebml<i64>> = VecDeque::new();
        let mut reference_virtual: VecDeque<Ebml<i64>> = VecDeque::new();
        let mut codec_state: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut discard_padding: VecDeque<Ebml<i64>> = VecDeque::new();
        let mut slices: VecDeque<Ebml<Slices>> = VecDeque::new();
        let mut reference_frame: VecDeque<Ebml<ReferenceFrame>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::Block => {
                    let size = size.try_sized(EbmlId::Block)?;
                    block.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockVirtual => {
                    let size = size.try_sized(EbmlId::BlockVirtual)?;
                    block_virtual.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockAdditions => {
                    let (val, read) = BlockAdditions::read_body(r, size).await?;
                    block_additions.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::BlockDuration => {
                    let size = size.try_sized(EbmlId::BlockDuration)?;
                    block_duration.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ReferencePriority => {
                    let size = size.try_sized(EbmlId::ReferencePriority)?;
                    reference_priority.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ReferenceBlock => {
                    let size = size.try_sized(EbmlId::ReferenceBlock)?;
                    reference_block.push_back(Ebml::new_index(index, async_::read_int(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ReferenceVirtual => {
                    let size = size.try_sized(EbmlId::ReferenceVirtual)?;
                    reference_virtual.push_back(Ebml::new_index(index, async_::read_int(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecState => {
                    let size = size.try_sized(EbmlId::CodecState)?;
                    codec_state.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DiscardPadding => {
                    let size = size.try_sized(EbmlId::DiscardPadding)?;
                    discard_padding.push_back(Ebml::new_index(index, async_::read_int(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Slices => {
                    let (val, read) = Slices::read_body(r, size).await?;
                    slices.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ReferenceFrame => {
                    let (val, read) = ReferenceFrame::read_body(r, size).await?;
                    reference_frame.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'BlockGroup'", id))?,
            }
            index += 1;
        }

        if block.len() != 1 { Err(anyhow::anyhow!("One element 'Block' must be in 'BlockGroup'. Found {}", block.len()))? }
        let block = block.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Block' doesn't exist in 'BlockGroup'"))?;
        if block_virtual.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockVirtual' in 'BlockGroup' possible. Found {}", block_virtual.len()))? }
        let block_virtual = block_virtual.pop_front();
        if block_additions.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAdditions' in 'BlockGroup' possible. Found {}", block_additions.len()))? }
        let block_additions = block_additions.pop_front();
        if block_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockDuration' in 'BlockGroup' possible. Found {}", block_duration.len()))? }
        let block_duration = block_duration.pop_front();
        if reference_priority.len() == 0 { reference_priority.push_back(Ebml::new(0)); }
        if reference_priority.len() != 1 { Err(anyhow::anyhow!("One element 'ReferencePriority' must be in 'BlockGroup'. Found {}", reference_priority.len()))? }
        let reference_priority = reference_priority.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ReferencePriority' doesn't exist in 'BlockGroup'"))?;
        let reference_block = Vec::from(reference_block);
        if reference_virtual.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ReferenceVirtual' in 'BlockGroup' possible. Found {}", reference_virtual.len()))? }
        let reference_virtual = reference_virtual.pop_front();
        if codec_state.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CodecState' in 'BlockGroup' possible. Found {}", codec_state.len()))? }
        let codec_state = codec_state.pop_front();
        if discard_padding.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DiscardPadding' in 'BlockGroup' possible. Found {}", discard_padding.len()))? }
        let discard_padding = discard_padding.pop_front();
        if slices.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Slices' in 'BlockGroup' possible. Found {}", slices.len()))? }
        let slices = slices.pop_front();
        if reference_frame.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ReferenceFrame' in 'BlockGroup' possible. Found {}", reference_frame.len()))? }
        let reference_frame = reference_frame.pop_front();

        Ok((Self{
            size,

            block,
            block_virtual,
            block_additions,
            block_duration,
            reference_priority,
            reference_block,
            reference_virtual,
            codec_state,
            discard_padding,
            slices,
            reference_frame,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for BlockAdditions {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::BlockAdditions { return Err(anyhow::anyhow!("BlockAdditions not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'BlockAdditions' unknown data size is not allowed")),
        };
        let mut block_more: VecDeque<Ebml<BlockMore>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::BlockMore => {
                    let (val, read) = BlockMore::read_body(r, size)?;
                    block_more.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'BlockAdditions'", id))?,
            }
            index += 1;
        }

        let block_more = Vec::from(block_more);

        Ok((Self{
            size,

            block_more,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for BlockAdditions {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::BlockAdditions { return Err(anyhow::anyhow!("BlockAdditions not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'BlockAdditions' unknown data size is not allowed")),
        };
        let mut block_more: VecDeque<Ebml<BlockMore>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::BlockMore => {
                    let (val, read) = BlockMore::read_body(r, size).await?;
                    block_more.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'BlockAdditions'", id))?,
            }
            index += 1;
        }

        let block_more = Vec::from(block_more);

        Ok((Self{
            size,

            block_more,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for BlockMore {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::BlockMore { return Err(anyhow::anyhow!("BlockMore not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'BlockMore' unknown data size is not allowed")),
        };
        let mut block_additional: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut block_add_id: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::BlockAdditional => {
                    let size = size.try_sized(EbmlId::BlockAdditional)?;
                    block_additional.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockAddId => {
                    let size = size.try_sized(EbmlId::BlockAddId)?;
                    block_add_id.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'BlockMore'", id))?,
            }
            index += 1;
        }

        if block_additional.len() != 1 { Err(anyhow::anyhow!("One element 'BlockAdditional' must be in 'BlockMore'. Found {}", block_additional.len()))? }
        let block_additional = block_additional.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'BlockAdditional' doesn't exist in 'BlockMore'"))?;
        if block_add_id.len() == 0 { block_add_id.push_back(Ebml::new(1)); }
        if block_add_id.len() != 1 { Err(anyhow::anyhow!("One element 'BlockAddId' must be in 'BlockMore'. Found {}", block_add_id.len()))? }
        let block_add_id = block_add_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'BlockAddId' doesn't exist in 'BlockMore'"))?;

        Ok((Self{
            size,

            block_additional,
            block_add_id,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for BlockMore {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::BlockMore { return Err(anyhow::anyhow!("BlockMore not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'BlockMore' unknown data size is not allowed")),
        };
        let mut block_additional: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut block_add_id: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::BlockAdditional => {
                    let size = size.try_sized(EbmlId::BlockAdditional)?;
                    block_additional.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockAddId => {
                    let size = size.try_sized(EbmlId::BlockAddId)?;
                    block_add_id.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'BlockMore'", id))?,
            }
            index += 1;
        }

        if block_additional.len() != 1 { Err(anyhow::anyhow!("One element 'BlockAdditional' must be in 'BlockMore'. Found {}", block_additional.len()))? }
        let block_additional = block_additional.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'BlockAdditional' doesn't exist in 'BlockMore'"))?;
        if block_add_id.len() == 0 { block_add_id.push_back(Ebml::new(1)); }
        if block_add_id.len() != 1 { Err(anyhow::anyhow!("One element 'BlockAddId' must be in 'BlockMore'. Found {}", block_add_id.len()))? }
        let block_add_id = block_add_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'BlockAddId' doesn't exist in 'BlockMore'"))?;

        Ok((Self{
            size,

            block_additional,
            block_add_id,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Slices {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Slices { return Err(anyhow::anyhow!("Slices not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Slices' unknown data size is not allowed")),
        };
        let mut time_slice: VecDeque<Ebml<TimeSlice>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TimeSlice => {
                    let (val, read) = TimeSlice::read_body(r, size)?;
                    time_slice.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Slices'", id))?,
            }
            index += 1;
        }

        let time_slice = Vec::from(time_slice);

        Ok((Self{
            size,

            time_slice,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Slices {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Slices { return Err(anyhow::anyhow!("Slices not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Slices' unknown data size is not allowed")),
        };
        let mut time_slice: VecDeque<Ebml<TimeSlice>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TimeSlice => {
                    let (val, read) = TimeSlice::read_body(r, size).await?;
                    time_slice.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Slices'", id))?,
            }
            index += 1;
        }

        let time_slice = Vec::from(time_slice);

        Ok((Self{
            size,

            time_slice,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for TimeSlice {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::TimeSlice { return Err(anyhow::anyhow!("TimeSlice not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TimeSlice' unknown data size is not allowed")),
        };
        let mut lace_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut frame_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut block_addition_id: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut delay: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut slice_duration: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::LaceNumber => {
                    let size = size.try_sized(EbmlId::LaceNumber)?;
                    lace_number.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FrameNumber => {
                    let size = size.try_sized(EbmlId::FrameNumber)?;
                    frame_number.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockAdditionId => {
                    let size = size.try_sized(EbmlId::BlockAdditionId)?;
                    block_addition_id.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Delay => {
                    let size = size.try_sized(EbmlId::Delay)?;
                    delay.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::SliceDuration => {
                    let size = size.try_sized(EbmlId::SliceDuration)?;
                    slice_duration.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TimeSlice'", id))?,
            }
            index += 1;
        }

        if lace_number.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'LaceNumber' in 'TimeSlice' possible. Found {}", lace_number.len()))? }
        let lace_number = lace_number.pop_front();
        if frame_number.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FrameNumber' in 'TimeSlice' possible. Found {}", frame_number.len()))? }
        let frame_number = frame_number.pop_front();
        if block_addition_id.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAdditionId' in 'TimeSlice' possible. Found {}", block_addition_id.len()))? }
        let block_addition_id = block_addition_id.pop_front();
        if delay.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Delay' in 'TimeSlice' possible. Found {}", delay.len()))? }
        let delay = delay.pop_front();
        if slice_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'SliceDuration' in 'TimeSlice' possible. Found {}", slice_duration.len()))? }
        let slice_duration = slice_duration.pop_front();

        Ok((Self{
            size,

            lace_number,
            frame_number,
            block_addition_id,
            delay,
            slice_duration,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for TimeSlice {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::TimeSlice { return Err(anyhow::anyhow!("TimeSlice not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TimeSlice' unknown data size is not allowed")),
        };
        let mut lace_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut frame_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut block_addition_id: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut delay: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut slice_duration: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::LaceNumber => {
                    let size = size.try_sized(EbmlId::LaceNumber)?;
                    lace_number.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FrameNumber => {
                    let size = size.try_sized(EbmlId::FrameNumber)?;
                    frame_number.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockAdditionId => {
                    let size = size.try_sized(EbmlId::BlockAdditionId)?;
                    block_addition_id.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Delay => {
                    let size = size.try_sized(EbmlId::Delay)?;
                    delay.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::SliceDuration => {
                    let size = size.try_sized(EbmlId::SliceDuration)?;
                    slice_duration.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TimeSlice'", id))?,
            }
            index += 1;
        }

        if lace_number.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'LaceNumber' in 'TimeSlice' possible. Found {}", lace_number.len()))? }
        let lace_number = lace_number.pop_front();
        if frame_number.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FrameNumber' in 'TimeSlice' possible. Found {}", frame_number.len()))? }
        let frame_number = frame_number.pop_front();
        if block_addition_id.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAdditionId' in 'TimeSlice' possible. Found {}", block_addition_id.len()))? }
        let block_addition_id = block_addition_id.pop_front();
        if delay.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Delay' in 'TimeSlice' possible. Found {}", delay.len()))? }
        let delay = delay.pop_front();
        if slice_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'SliceDuration' in 'TimeSlice' possible. Found {}", slice_duration.len()))? }
        let slice_duration = slice_duration.pop_front();

        Ok((Self{
            size,

            lace_number,
            frame_number,
            block_addition_id,
            delay,
            slice_duration,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ReferenceFrame {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ReferenceFrame { return Err(anyhow::anyhow!("ReferenceFrame not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ReferenceFrame' unknown data size is not allowed")),
        };
        let mut reference_offset: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut reference_timestamp: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ReferenceOffset => {
                    let size = size.try_sized(EbmlId::ReferenceOffset)?;
                    reference_offset.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ReferenceTimestamp => {
                    let size = size.try_sized(EbmlId::ReferenceTimestamp)?;
                    reference_timestamp.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ReferenceFrame'", id))?,
            }
            index += 1;
        }

        if reference_offset.len() != 1 { Err(anyhow::anyhow!("One element 'ReferenceOffset' must be in 'ReferenceFrame'. Found {}", reference_offset.len()))? }
        let reference_offset = reference_offset.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ReferenceOffset' doesn't exist in 'ReferenceFrame'"))?;
        if reference_timestamp.len() != 1 { Err(anyhow::anyhow!("One element 'ReferenceTimestamp' must be in 'ReferenceFrame'. Found {}", reference_timestamp.len()))? }
        let reference_timestamp = reference_timestamp.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ReferenceTimestamp' doesn't exist in 'ReferenceFrame'"))?;

        Ok((Self{
            size,

            reference_offset,
            reference_timestamp,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ReferenceFrame {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ReferenceFrame { return Err(anyhow::anyhow!("ReferenceFrame not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ReferenceFrame' unknown data size is not allowed")),
        };
        let mut reference_offset: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut reference_timestamp: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ReferenceOffset => {
                    let size = size.try_sized(EbmlId::ReferenceOffset)?;
                    reference_offset.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ReferenceTimestamp => {
                    let size = size.try_sized(EbmlId::ReferenceTimestamp)?;
                    reference_timestamp.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ReferenceFrame'", id))?,
            }
            index += 1;
        }

        if reference_offset.len() != 1 { Err(anyhow::anyhow!("One element 'ReferenceOffset' must be in 'ReferenceFrame'. Found {}", reference_offset.len()))? }
        let reference_offset = reference_offset.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ReferenceOffset' doesn't exist in 'ReferenceFrame'"))?;
        if reference_timestamp.len() != 1 { Err(anyhow::anyhow!("One element 'ReferenceTimestamp' must be in 'ReferenceFrame'. Found {}", reference_timestamp.len()))? }
        let reference_timestamp = reference_timestamp.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ReferenceTimestamp' doesn't exist in 'ReferenceFrame'"))?;

        Ok((Self{
            size,

            reference_offset,
            reference_timestamp,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Tracks {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Tracks { return Err(anyhow::anyhow!("Tracks not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Tracks' unknown data size is not allowed")),
        };
        let mut track_entry: VecDeque<Ebml<TrackEntry>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackEntry => {
                    let (val, read) = TrackEntry::read_body(r, size)?;
                    track_entry.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Tracks'", id))?,
            }
            index += 1;
        }

        let track_entry = Vec::from(track_entry);

        Ok((Self{
            size,

            track_entry,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Tracks {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Tracks { return Err(anyhow::anyhow!("Tracks not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Tracks' unknown data size is not allowed")),
        };
        let mut track_entry: VecDeque<Ebml<TrackEntry>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackEntry => {
                    let (val, read) = TrackEntry::read_body(r, size).await?;
                    track_entry.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Tracks'", id))?,
            }
            index += 1;
        }

        let track_entry = Vec::from(track_entry);

        Ok((Self{
            size,

            track_entry,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for TrackEntry {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::TrackEntry { return Err(anyhow::anyhow!("TrackEntry not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackEntry' unknown data size is not allowed")),
        };
        let mut track_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_enabled: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_default: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_forced: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_hearing_impaired: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_visual_impaired: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_text_descriptions: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_original: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_commentary: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_lacing: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut min_cache: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut max_cache: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut default_duration: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut default_decoded_field_duration: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_timestamp_scale: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut track_offset: VecDeque<Ebml<i64>> = VecDeque::new();
        let mut max_block_addition_id: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut block_addition_mapping: VecDeque<Ebml<BlockAdditionMapping>> = VecDeque::new();
        let mut name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut language: VecDeque<Ebml<String>> = VecDeque::new();
        let mut language_bcp_47: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_id: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_private: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut codec_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut attachment_link: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut codec_settings: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_info_url: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_download_url: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_decode_all: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_overlay: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut codec_delay: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut seek_pre_roll: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_translate: VecDeque<Ebml<TrackTranslate>> = VecDeque::new();
        let mut video: VecDeque<Ebml<Video>> = VecDeque::new();
        let mut audio: VecDeque<Ebml<Audio>> = VecDeque::new();
        let mut track_operation: VecDeque<Ebml<TrackOperation>> = VecDeque::new();
        let mut trick_track_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut trick_track_segment_uid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut trick_track_flag: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut trick_struct_track_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut trick_struct_track_segment_uid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut content_encodings: VecDeque<Ebml<ContentEncodings>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackNumber => {
                    let size = size.try_sized(EbmlId::TrackNumber)?;
                    track_number.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackUid => {
                    let size = size.try_sized(EbmlId::TrackUid)?;
                    track_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackType => {
                    let size = size.try_sized(EbmlId::TrackType)?;
                    track_type.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagEnabled => {
                    let size = size.try_sized(EbmlId::FlagEnabled)?;
                    flag_enabled.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagDefault => {
                    let size = size.try_sized(EbmlId::FlagDefault)?;
                    flag_default.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagForced => {
                    let size = size.try_sized(EbmlId::FlagForced)?;
                    flag_forced.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagHearingImpaired => {
                    let size = size.try_sized(EbmlId::FlagHearingImpaired)?;
                    flag_hearing_impaired.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagVisualImpaired => {
                    let size = size.try_sized(EbmlId::FlagVisualImpaired)?;
                    flag_visual_impaired.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagTextDescriptions => {
                    let size = size.try_sized(EbmlId::FlagTextDescriptions)?;
                    flag_text_descriptions.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagOriginal => {
                    let size = size.try_sized(EbmlId::FlagOriginal)?;
                    flag_original.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagCommentary => {
                    let size = size.try_sized(EbmlId::FlagCommentary)?;
                    flag_commentary.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FlagLacing => {
                    let size = size.try_sized(EbmlId::FlagLacing)?;
                    flag_lacing.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::MinCache => {
                    let size = size.try_sized(EbmlId::MinCache)?;
                    min_cache.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::MaxCache => {
                    let size = size.try_sized(EbmlId::MaxCache)?;
                    max_cache.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DefaultDuration => {
                    let size = size.try_sized(EbmlId::DefaultDuration)?;
                    default_duration.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DefaultDecodedFieldDuration => {
                    let size = size.try_sized(EbmlId::DefaultDecodedFieldDuration)?;
                    default_decoded_field_duration.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackTimestampScale => {
                    let size = size.try_sized(EbmlId::TrackTimestampScale)?;
                    track_timestamp_scale.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackOffset => {
                    let size = size.try_sized(EbmlId::TrackOffset)?;
                    track_offset.push_back(Ebml::new_index(index, blocking::read_int(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::MaxBlockAdditionId => {
                    let size = size.try_sized(EbmlId::MaxBlockAdditionId)?;
                    max_block_addition_id.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockAdditionMapping => {
                    let (val, read) = BlockAdditionMapping::read_body(r, size)?;
                    block_addition_mapping.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Name => {
                    let size = size.try_sized(EbmlId::Name)?;
                    name.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Language => {
                    let size = size.try_sized(EbmlId::Language)?;
                    language.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::LanguageBcp47 => {
                    let size = size.try_sized(EbmlId::LanguageBcp47)?;
                    language_bcp_47.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecId => {
                    let size = size.try_sized(EbmlId::CodecId)?;
                    codec_id.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecPrivate => {
                    let size = size.try_sized(EbmlId::CodecPrivate)?;
                    codec_private.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecName => {
                    let size = size.try_sized(EbmlId::CodecName)?;
                    codec_name.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::AttachmentLink => {
                    let size = size.try_sized(EbmlId::AttachmentLink)?;
                    attachment_link.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecSettings => {
                    let size = size.try_sized(EbmlId::CodecSettings)?;
                    codec_settings.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecInfoUrl => {
                    let size = size.try_sized(EbmlId::CodecInfoUrl)?;
                    codec_info_url.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecDownloadUrl => {
                    let size = size.try_sized(EbmlId::CodecDownloadUrl)?;
                    codec_download_url.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecDecodeAll => {
                    let size = size.try_sized(EbmlId::CodecDecodeAll)?;
                    codec_decode_all.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackOverlay => {
                    let size = size.try_sized(EbmlId::TrackOverlay)?;
                    track_overlay.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CodecDelay => {
                    let size = size.try_sized(EbmlId::CodecDelay)?;
                    codec_delay.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::SeekPreRoll => {
                    let size = size.try_sized(EbmlId::SeekPreRoll)?;
                    seek_pre_roll.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackTranslate => {
                    let (val, read) = TrackTranslate::read_body(r, size)?;
                    track_translate.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Video => {
                    let (val, read) = Video::read_body(r, size)?;
                    video.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Audio => {
                    let (val, read) = Audio::read_body(r, size)?;
                    audio.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::TrackOperation => {
                    let (val, read) = TrackOperation::read_body(r, size)?;
                    track_operation.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::TrickTrackUid => {
                    let size = size.try_sized(EbmlId::TrickTrackUid)?;
                    trick_track_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrickTrackSegmentUid => {
                    let size = size.try_sized(EbmlId::TrickTrackSegmentUid)?;
                    trick_track_segment_uid.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrickTrackFlag => {
                    let size = size.try_sized(EbmlId::TrickTrackFlag)?;
                    trick_track_flag.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrickStructTrackUid => {
                    let size = size.try_sized(EbmlId::TrickStructTrackUid)?;
                    trick_struct_track_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrickStructTrackSegmentUid => {
                    let size = size.try_sized(EbmlId::TrickStructTrackSegmentUid)?;
                    trick_struct_track_segment_uid.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncodings => {
                    let (val, read) = ContentEncodings::read_body(r, size)?;
                    content_encodings.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackEntry'", id))?,
            }
            index += 1;
        }

        if track_number.len() != 1 { Err(anyhow::anyhow!("One element 'TrackNumber' must be in 'TrackEntry'. Found {}", track_number.len()))? }
        let track_number = track_number.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackNumber' doesn't exist in 'TrackEntry'"))?;
        if track_uid.len() != 1 { Err(anyhow::anyhow!("One element 'TrackUid' must be in 'TrackEntry'. Found {}", track_uid.len()))? }
        let track_uid = track_uid.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackUid' doesn't exist in 'TrackEntry'"))?;
        if track_type.len() != 1 { Err(anyhow::anyhow!("One element 'TrackType' must be in 'TrackEntry'. Found {}", track_type.len()))? }
        let track_type = track_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackType' doesn't exist in 'TrackEntry'"))?;
        if flag_enabled.len() == 0 { flag_enabled.push_back(Ebml::new(1)); }
        if flag_enabled.len() != 1 { Err(anyhow::anyhow!("One element 'FlagEnabled' must be in 'TrackEntry'. Found {}", flag_enabled.len()))? }
        let flag_enabled = flag_enabled.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagEnabled' doesn't exist in 'TrackEntry'"))?;
        if flag_default.len() == 0 { flag_default.push_back(Ebml::new(1)); }
        if flag_default.len() != 1 { Err(anyhow::anyhow!("One element 'FlagDefault' must be in 'TrackEntry'. Found {}", flag_default.len()))? }
        let flag_default = flag_default.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagDefault' doesn't exist in 'TrackEntry'"))?;
        if flag_forced.len() == 0 { flag_forced.push_back(Ebml::new(0)); }
        if flag_forced.len() != 1 { Err(anyhow::anyhow!("One element 'FlagForced' must be in 'TrackEntry'. Found {}", flag_forced.len()))? }
        let flag_forced = flag_forced.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagForced' doesn't exist in 'TrackEntry'"))?;
        if flag_hearing_impaired.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagHearingImpaired' in 'TrackEntry' possible. Found {}", flag_hearing_impaired.len()))? }
        let flag_hearing_impaired = flag_hearing_impaired.pop_front();
        if flag_visual_impaired.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagVisualImpaired' in 'TrackEntry' possible. Found {}", flag_visual_impaired.len()))? }
        let flag_visual_impaired = flag_visual_impaired.pop_front();
        if flag_text_descriptions.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagTextDescriptions' in 'TrackEntry' possible. Found {}", flag_text_descriptions.len()))? }
        let flag_text_descriptions = flag_text_descriptions.pop_front();
        if flag_original.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagOriginal' in 'TrackEntry' possible. Found {}", flag_original.len()))? }
        let flag_original = flag_original.pop_front();
        if flag_commentary.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagCommentary' in 'TrackEntry' possible. Found {}", flag_commentary.len()))? }
        let flag_commentary = flag_commentary.pop_front();
        if flag_lacing.len() == 0 { flag_lacing.push_back(Ebml::new(1)); }
        if flag_lacing.len() != 1 { Err(anyhow::anyhow!("One element 'FlagLacing' must be in 'TrackEntry'. Found {}", flag_lacing.len()))? }
        let flag_lacing = flag_lacing.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagLacing' doesn't exist in 'TrackEntry'"))?;
        if min_cache.len() == 0 { min_cache.push_back(Ebml::new(0)); }
        if min_cache.len() != 1 { Err(anyhow::anyhow!("One element 'MinCache' must be in 'TrackEntry'. Found {}", min_cache.len()))? }
        let min_cache = min_cache.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'MinCache' doesn't exist in 'TrackEntry'"))?;
        if max_cache.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'MaxCache' in 'TrackEntry' possible. Found {}", max_cache.len()))? }
        let max_cache = max_cache.pop_front();
        if default_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DefaultDuration' in 'TrackEntry' possible. Found {}", default_duration.len()))? }
        let default_duration = default_duration.pop_front();
        if default_decoded_field_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DefaultDecodedFieldDuration' in 'TrackEntry' possible. Found {}", default_decoded_field_duration.len()))? }
        let default_decoded_field_duration = default_decoded_field_duration.pop_front();
        if track_timestamp_scale.len() == 0 { track_timestamp_scale.push_back(Ebml::new(hexf::hexf64!("0x1p+0"))); }
        if track_timestamp_scale.len() != 1 { Err(anyhow::anyhow!("One element 'TrackTimestampScale' must be in 'TrackEntry'. Found {}", track_timestamp_scale.len()))? }
        let track_timestamp_scale = track_timestamp_scale.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackTimestampScale' doesn't exist in 'TrackEntry'"))?;
        if track_offset.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrackOffset' in 'TrackEntry' possible. Found {}", track_offset.len()))? }
        let track_offset = track_offset.pop_front();
        if max_block_addition_id.len() == 0 { max_block_addition_id.push_back(Ebml::new(0)); }
        if max_block_addition_id.len() != 1 { Err(anyhow::anyhow!("One element 'MaxBlockAdditionId' must be in 'TrackEntry'. Found {}", max_block_addition_id.len()))? }
        let max_block_addition_id = max_block_addition_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'MaxBlockAdditionId' doesn't exist in 'TrackEntry'"))?;
        let block_addition_mapping = Vec::from(block_addition_mapping);
        if name.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Name' in 'TrackEntry' possible. Found {}", name.len()))? }
        let name = name.pop_front();
        if language.len() == 0 { language.push_back(Ebml::new("eng".to_string())); }
        if language.len() != 1 { Err(anyhow::anyhow!("One element 'Language' must be in 'TrackEntry'. Found {}", language.len()))? }
        let language = language.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Language' doesn't exist in 'TrackEntry'"))?;
        if language_bcp_47.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'LanguageBcp47' in 'TrackEntry' possible. Found {}", language_bcp_47.len()))? }
        let language_bcp_47 = language_bcp_47.pop_front();
        if codec_id.len() != 1 { Err(anyhow::anyhow!("One element 'CodecId' must be in 'TrackEntry'. Found {}", codec_id.len()))? }
        let codec_id = codec_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CodecId' doesn't exist in 'TrackEntry'"))?;
        if codec_private.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CodecPrivate' in 'TrackEntry' possible. Found {}", codec_private.len()))? }
        let codec_private = codec_private.pop_front();
        if codec_name.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CodecName' in 'TrackEntry' possible. Found {}", codec_name.len()))? }
        let codec_name = codec_name.pop_front();
        if attachment_link.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'AttachmentLink' in 'TrackEntry' possible. Found {}", attachment_link.len()))? }
        let attachment_link = attachment_link.pop_front();
        if codec_settings.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CodecSettings' in 'TrackEntry' possible. Found {}", codec_settings.len()))? }
        let codec_settings = codec_settings.pop_front();
        let codec_info_url = Vec::from(codec_info_url);
        let codec_download_url = Vec::from(codec_download_url);
        if codec_decode_all.len() == 0 { codec_decode_all.push_back(Ebml::new(1)); }
        if codec_decode_all.len() != 1 { Err(anyhow::anyhow!("One element 'CodecDecodeAll' must be in 'TrackEntry'. Found {}", codec_decode_all.len()))? }
        let codec_decode_all = codec_decode_all.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CodecDecodeAll' doesn't exist in 'TrackEntry'"))?;
        let track_overlay = Vec::from(track_overlay);
        if codec_delay.len() == 0 { codec_delay.push_back(Ebml::new(0)); }
        if codec_delay.len() != 1 { Err(anyhow::anyhow!("One element 'CodecDelay' must be in 'TrackEntry'. Found {}", codec_delay.len()))? }
        let codec_delay = codec_delay.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CodecDelay' doesn't exist in 'TrackEntry'"))?;
        if seek_pre_roll.len() == 0 { seek_pre_roll.push_back(Ebml::new(0)); }
        if seek_pre_roll.len() != 1 { Err(anyhow::anyhow!("One element 'SeekPreRoll' must be in 'TrackEntry'. Found {}", seek_pre_roll.len()))? }
        let seek_pre_roll = seek_pre_roll.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'SeekPreRoll' doesn't exist in 'TrackEntry'"))?;
        let track_translate = Vec::from(track_translate);
        if video.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Video' in 'TrackEntry' possible. Found {}", video.len()))? }
        let video = video.pop_front();
        if audio.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Audio' in 'TrackEntry' possible. Found {}", audio.len()))? }
        let audio = audio.pop_front();
        if track_operation.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrackOperation' in 'TrackEntry' possible. Found {}", track_operation.len()))? }
        let track_operation = track_operation.pop_front();
        if trick_track_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickTrackUid' in 'TrackEntry' possible. Found {}", trick_track_uid.len()))? }
        let trick_track_uid = trick_track_uid.pop_front();
        if trick_track_segment_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickTrackSegmentUid' in 'TrackEntry' possible. Found {}", trick_track_segment_uid.len()))? }
        let trick_track_segment_uid = trick_track_segment_uid.pop_front();
        if trick_track_flag.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickTrackFlag' in 'TrackEntry' possible. Found {}", trick_track_flag.len()))? }
        let trick_track_flag = trick_track_flag.pop_front();
        if trick_struct_track_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickStructTrackUid' in 'TrackEntry' possible. Found {}", trick_struct_track_uid.len()))? }
        let trick_struct_track_uid = trick_struct_track_uid.pop_front();
        if trick_struct_track_segment_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickStructTrackSegmentUid' in 'TrackEntry' possible. Found {}", trick_struct_track_segment_uid.len()))? }
        let trick_struct_track_segment_uid = trick_struct_track_segment_uid.pop_front();
        if content_encodings.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentEncodings' in 'TrackEntry' possible. Found {}", content_encodings.len()))? }
        let content_encodings = content_encodings.pop_front();

        Ok((Self{
            size,

            track_number,
            track_uid,
            track_type,
            flag_enabled,
            flag_default,
            flag_forced,
            flag_hearing_impaired,
            flag_visual_impaired,
            flag_text_descriptions,
            flag_original,
            flag_commentary,
            flag_lacing,
            min_cache,
            max_cache,
            default_duration,
            default_decoded_field_duration,
            track_timestamp_scale,
            track_offset,
            max_block_addition_id,
            block_addition_mapping,
            name,
            language,
            language_bcp_47,
            codec_id,
            codec_private,
            codec_name,
            attachment_link,
            codec_settings,
            codec_info_url,
            codec_download_url,
            codec_decode_all,
            track_overlay,
            codec_delay,
            seek_pre_roll,
            track_translate,
            video,
            audio,
            track_operation,
            trick_track_uid,
            trick_track_segment_uid,
            trick_track_flag,
            trick_struct_track_uid,
            trick_struct_track_segment_uid,
            content_encodings,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for TrackEntry {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::TrackEntry { return Err(anyhow::anyhow!("TrackEntry not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackEntry' unknown data size is not allowed")),
        };
        let mut track_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_enabled: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_default: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_forced: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_hearing_impaired: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_visual_impaired: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_text_descriptions: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_original: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_commentary: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut flag_lacing: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut min_cache: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut max_cache: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut default_duration: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut default_decoded_field_duration: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_timestamp_scale: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut track_offset: VecDeque<Ebml<i64>> = VecDeque::new();
        let mut max_block_addition_id: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut block_addition_mapping: VecDeque<Ebml<BlockAdditionMapping>> = VecDeque::new();
        let mut name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut language: VecDeque<Ebml<String>> = VecDeque::new();
        let mut language_bcp_47: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_id: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_private: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut codec_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut attachment_link: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut codec_settings: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_info_url: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_download_url: VecDeque<Ebml<String>> = VecDeque::new();
        let mut codec_decode_all: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_overlay: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut codec_delay: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut seek_pre_roll: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_translate: VecDeque<Ebml<TrackTranslate>> = VecDeque::new();
        let mut video: VecDeque<Ebml<Video>> = VecDeque::new();
        let mut audio: VecDeque<Ebml<Audio>> = VecDeque::new();
        let mut track_operation: VecDeque<Ebml<TrackOperation>> = VecDeque::new();
        let mut trick_track_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut trick_track_segment_uid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut trick_track_flag: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut trick_struct_track_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut trick_struct_track_segment_uid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut content_encodings: VecDeque<Ebml<ContentEncodings>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackNumber => {
                    let size = size.try_sized(EbmlId::TrackNumber)?;
                    track_number.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackUid => {
                    let size = size.try_sized(EbmlId::TrackUid)?;
                    track_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackType => {
                    let size = size.try_sized(EbmlId::TrackType)?;
                    track_type.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagEnabled => {
                    let size = size.try_sized(EbmlId::FlagEnabled)?;
                    flag_enabled.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagDefault => {
                    let size = size.try_sized(EbmlId::FlagDefault)?;
                    flag_default.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagForced => {
                    let size = size.try_sized(EbmlId::FlagForced)?;
                    flag_forced.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagHearingImpaired => {
                    let size = size.try_sized(EbmlId::FlagHearingImpaired)?;
                    flag_hearing_impaired.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagVisualImpaired => {
                    let size = size.try_sized(EbmlId::FlagVisualImpaired)?;
                    flag_visual_impaired.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagTextDescriptions => {
                    let size = size.try_sized(EbmlId::FlagTextDescriptions)?;
                    flag_text_descriptions.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagOriginal => {
                    let size = size.try_sized(EbmlId::FlagOriginal)?;
                    flag_original.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagCommentary => {
                    let size = size.try_sized(EbmlId::FlagCommentary)?;
                    flag_commentary.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FlagLacing => {
                    let size = size.try_sized(EbmlId::FlagLacing)?;
                    flag_lacing.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::MinCache => {
                    let size = size.try_sized(EbmlId::MinCache)?;
                    min_cache.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::MaxCache => {
                    let size = size.try_sized(EbmlId::MaxCache)?;
                    max_cache.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DefaultDuration => {
                    let size = size.try_sized(EbmlId::DefaultDuration)?;
                    default_duration.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DefaultDecodedFieldDuration => {
                    let size = size.try_sized(EbmlId::DefaultDecodedFieldDuration)?;
                    default_decoded_field_duration.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackTimestampScale => {
                    let size = size.try_sized(EbmlId::TrackTimestampScale)?;
                    track_timestamp_scale.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackOffset => {
                    let size = size.try_sized(EbmlId::TrackOffset)?;
                    track_offset.push_back(Ebml::new_index(index, async_::read_int(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::MaxBlockAdditionId => {
                    let size = size.try_sized(EbmlId::MaxBlockAdditionId)?;
                    max_block_addition_id.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockAdditionMapping => {
                    let (val, read) = BlockAdditionMapping::read_body(r, size).await?;
                    block_addition_mapping.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Name => {
                    let size = size.try_sized(EbmlId::Name)?;
                    name.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Language => {
                    let size = size.try_sized(EbmlId::Language)?;
                    language.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::LanguageBcp47 => {
                    let size = size.try_sized(EbmlId::LanguageBcp47)?;
                    language_bcp_47.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecId => {
                    let size = size.try_sized(EbmlId::CodecId)?;
                    codec_id.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecPrivate => {
                    let size = size.try_sized(EbmlId::CodecPrivate)?;
                    codec_private.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecName => {
                    let size = size.try_sized(EbmlId::CodecName)?;
                    codec_name.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::AttachmentLink => {
                    let size = size.try_sized(EbmlId::AttachmentLink)?;
                    attachment_link.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecSettings => {
                    let size = size.try_sized(EbmlId::CodecSettings)?;
                    codec_settings.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecInfoUrl => {
                    let size = size.try_sized(EbmlId::CodecInfoUrl)?;
                    codec_info_url.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecDownloadUrl => {
                    let size = size.try_sized(EbmlId::CodecDownloadUrl)?;
                    codec_download_url.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecDecodeAll => {
                    let size = size.try_sized(EbmlId::CodecDecodeAll)?;
                    codec_decode_all.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackOverlay => {
                    let size = size.try_sized(EbmlId::TrackOverlay)?;
                    track_overlay.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CodecDelay => {
                    let size = size.try_sized(EbmlId::CodecDelay)?;
                    codec_delay.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::SeekPreRoll => {
                    let size = size.try_sized(EbmlId::SeekPreRoll)?;
                    seek_pre_roll.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackTranslate => {
                    let (val, read) = TrackTranslate::read_body(r, size).await?;
                    track_translate.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Video => {
                    let (val, read) = Video::read_body(r, size).await?;
                    video.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Audio => {
                    let (val, read) = Audio::read_body(r, size).await?;
                    audio.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::TrackOperation => {
                    let (val, read) = TrackOperation::read_body(r, size).await?;
                    track_operation.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::TrickTrackUid => {
                    let size = size.try_sized(EbmlId::TrickTrackUid)?;
                    trick_track_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrickTrackSegmentUid => {
                    let size = size.try_sized(EbmlId::TrickTrackSegmentUid)?;
                    trick_track_segment_uid.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrickTrackFlag => {
                    let size = size.try_sized(EbmlId::TrickTrackFlag)?;
                    trick_track_flag.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrickStructTrackUid => {
                    let size = size.try_sized(EbmlId::TrickStructTrackUid)?;
                    trick_struct_track_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrickStructTrackSegmentUid => {
                    let size = size.try_sized(EbmlId::TrickStructTrackSegmentUid)?;
                    trick_struct_track_segment_uid.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncodings => {
                    let (val, read) = ContentEncodings::read_body(r, size).await?;
                    content_encodings.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackEntry'", id))?,
            }
            index += 1;
        }

        if track_number.len() != 1 { Err(anyhow::anyhow!("One element 'TrackNumber' must be in 'TrackEntry'. Found {}", track_number.len()))? }
        let track_number = track_number.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackNumber' doesn't exist in 'TrackEntry'"))?;
        if track_uid.len() != 1 { Err(anyhow::anyhow!("One element 'TrackUid' must be in 'TrackEntry'. Found {}", track_uid.len()))? }
        let track_uid = track_uid.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackUid' doesn't exist in 'TrackEntry'"))?;
        if track_type.len() != 1 { Err(anyhow::anyhow!("One element 'TrackType' must be in 'TrackEntry'. Found {}", track_type.len()))? }
        let track_type = track_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackType' doesn't exist in 'TrackEntry'"))?;
        if flag_enabled.len() == 0 { flag_enabled.push_back(Ebml::new(1)); }
        if flag_enabled.len() != 1 { Err(anyhow::anyhow!("One element 'FlagEnabled' must be in 'TrackEntry'. Found {}", flag_enabled.len()))? }
        let flag_enabled = flag_enabled.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagEnabled' doesn't exist in 'TrackEntry'"))?;
        if flag_default.len() == 0 { flag_default.push_back(Ebml::new(1)); }
        if flag_default.len() != 1 { Err(anyhow::anyhow!("One element 'FlagDefault' must be in 'TrackEntry'. Found {}", flag_default.len()))? }
        let flag_default = flag_default.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagDefault' doesn't exist in 'TrackEntry'"))?;
        if flag_forced.len() == 0 { flag_forced.push_back(Ebml::new(0)); }
        if flag_forced.len() != 1 { Err(anyhow::anyhow!("One element 'FlagForced' must be in 'TrackEntry'. Found {}", flag_forced.len()))? }
        let flag_forced = flag_forced.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagForced' doesn't exist in 'TrackEntry'"))?;
        if flag_hearing_impaired.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagHearingImpaired' in 'TrackEntry' possible. Found {}", flag_hearing_impaired.len()))? }
        let flag_hearing_impaired = flag_hearing_impaired.pop_front();
        if flag_visual_impaired.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagVisualImpaired' in 'TrackEntry' possible. Found {}", flag_visual_impaired.len()))? }
        let flag_visual_impaired = flag_visual_impaired.pop_front();
        if flag_text_descriptions.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagTextDescriptions' in 'TrackEntry' possible. Found {}", flag_text_descriptions.len()))? }
        let flag_text_descriptions = flag_text_descriptions.pop_front();
        if flag_original.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagOriginal' in 'TrackEntry' possible. Found {}", flag_original.len()))? }
        let flag_original = flag_original.pop_front();
        if flag_commentary.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FlagCommentary' in 'TrackEntry' possible. Found {}", flag_commentary.len()))? }
        let flag_commentary = flag_commentary.pop_front();
        if flag_lacing.len() == 0 { flag_lacing.push_back(Ebml::new(1)); }
        if flag_lacing.len() != 1 { Err(anyhow::anyhow!("One element 'FlagLacing' must be in 'TrackEntry'. Found {}", flag_lacing.len()))? }
        let flag_lacing = flag_lacing.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagLacing' doesn't exist in 'TrackEntry'"))?;
        if min_cache.len() == 0 { min_cache.push_back(Ebml::new(0)); }
        if min_cache.len() != 1 { Err(anyhow::anyhow!("One element 'MinCache' must be in 'TrackEntry'. Found {}", min_cache.len()))? }
        let min_cache = min_cache.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'MinCache' doesn't exist in 'TrackEntry'"))?;
        if max_cache.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'MaxCache' in 'TrackEntry' possible. Found {}", max_cache.len()))? }
        let max_cache = max_cache.pop_front();
        if default_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DefaultDuration' in 'TrackEntry' possible. Found {}", default_duration.len()))? }
        let default_duration = default_duration.pop_front();
        if default_decoded_field_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DefaultDecodedFieldDuration' in 'TrackEntry' possible. Found {}", default_decoded_field_duration.len()))? }
        let default_decoded_field_duration = default_decoded_field_duration.pop_front();
        if track_timestamp_scale.len() == 0 { track_timestamp_scale.push_back(Ebml::new(hexf::hexf64!("0x1p+0"))); }
        if track_timestamp_scale.len() != 1 { Err(anyhow::anyhow!("One element 'TrackTimestampScale' must be in 'TrackEntry'. Found {}", track_timestamp_scale.len()))? }
        let track_timestamp_scale = track_timestamp_scale.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackTimestampScale' doesn't exist in 'TrackEntry'"))?;
        if track_offset.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrackOffset' in 'TrackEntry' possible. Found {}", track_offset.len()))? }
        let track_offset = track_offset.pop_front();
        if max_block_addition_id.len() == 0 { max_block_addition_id.push_back(Ebml::new(0)); }
        if max_block_addition_id.len() != 1 { Err(anyhow::anyhow!("One element 'MaxBlockAdditionId' must be in 'TrackEntry'. Found {}", max_block_addition_id.len()))? }
        let max_block_addition_id = max_block_addition_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'MaxBlockAdditionId' doesn't exist in 'TrackEntry'"))?;
        let block_addition_mapping = Vec::from(block_addition_mapping);
        if name.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Name' in 'TrackEntry' possible. Found {}", name.len()))? }
        let name = name.pop_front();
        if language.len() == 0 { language.push_back(Ebml::new("eng".to_string())); }
        if language.len() != 1 { Err(anyhow::anyhow!("One element 'Language' must be in 'TrackEntry'. Found {}", language.len()))? }
        let language = language.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Language' doesn't exist in 'TrackEntry'"))?;
        if language_bcp_47.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'LanguageBcp47' in 'TrackEntry' possible. Found {}", language_bcp_47.len()))? }
        let language_bcp_47 = language_bcp_47.pop_front();
        if codec_id.len() != 1 { Err(anyhow::anyhow!("One element 'CodecId' must be in 'TrackEntry'. Found {}", codec_id.len()))? }
        let codec_id = codec_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CodecId' doesn't exist in 'TrackEntry'"))?;
        if codec_private.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CodecPrivate' in 'TrackEntry' possible. Found {}", codec_private.len()))? }
        let codec_private = codec_private.pop_front();
        if codec_name.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CodecName' in 'TrackEntry' possible. Found {}", codec_name.len()))? }
        let codec_name = codec_name.pop_front();
        if attachment_link.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'AttachmentLink' in 'TrackEntry' possible. Found {}", attachment_link.len()))? }
        let attachment_link = attachment_link.pop_front();
        if codec_settings.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CodecSettings' in 'TrackEntry' possible. Found {}", codec_settings.len()))? }
        let codec_settings = codec_settings.pop_front();
        let codec_info_url = Vec::from(codec_info_url);
        let codec_download_url = Vec::from(codec_download_url);
        if codec_decode_all.len() == 0 { codec_decode_all.push_back(Ebml::new(1)); }
        if codec_decode_all.len() != 1 { Err(anyhow::anyhow!("One element 'CodecDecodeAll' must be in 'TrackEntry'. Found {}", codec_decode_all.len()))? }
        let codec_decode_all = codec_decode_all.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CodecDecodeAll' doesn't exist in 'TrackEntry'"))?;
        let track_overlay = Vec::from(track_overlay);
        if codec_delay.len() == 0 { codec_delay.push_back(Ebml::new(0)); }
        if codec_delay.len() != 1 { Err(anyhow::anyhow!("One element 'CodecDelay' must be in 'TrackEntry'. Found {}", codec_delay.len()))? }
        let codec_delay = codec_delay.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CodecDelay' doesn't exist in 'TrackEntry'"))?;
        if seek_pre_roll.len() == 0 { seek_pre_roll.push_back(Ebml::new(0)); }
        if seek_pre_roll.len() != 1 { Err(anyhow::anyhow!("One element 'SeekPreRoll' must be in 'TrackEntry'. Found {}", seek_pre_roll.len()))? }
        let seek_pre_roll = seek_pre_roll.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'SeekPreRoll' doesn't exist in 'TrackEntry'"))?;
        let track_translate = Vec::from(track_translate);
        if video.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Video' in 'TrackEntry' possible. Found {}", video.len()))? }
        let video = video.pop_front();
        if audio.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Audio' in 'TrackEntry' possible. Found {}", audio.len()))? }
        let audio = audio.pop_front();
        if track_operation.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrackOperation' in 'TrackEntry' possible. Found {}", track_operation.len()))? }
        let track_operation = track_operation.pop_front();
        if trick_track_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickTrackUid' in 'TrackEntry' possible. Found {}", trick_track_uid.len()))? }
        let trick_track_uid = trick_track_uid.pop_front();
        if trick_track_segment_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickTrackSegmentUid' in 'TrackEntry' possible. Found {}", trick_track_segment_uid.len()))? }
        let trick_track_segment_uid = trick_track_segment_uid.pop_front();
        if trick_track_flag.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickTrackFlag' in 'TrackEntry' possible. Found {}", trick_track_flag.len()))? }
        let trick_track_flag = trick_track_flag.pop_front();
        if trick_struct_track_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickStructTrackUid' in 'TrackEntry' possible. Found {}", trick_struct_track_uid.len()))? }
        let trick_struct_track_uid = trick_struct_track_uid.pop_front();
        if trick_struct_track_segment_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrickStructTrackSegmentUid' in 'TrackEntry' possible. Found {}", trick_struct_track_segment_uid.len()))? }
        let trick_struct_track_segment_uid = trick_struct_track_segment_uid.pop_front();
        if content_encodings.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentEncodings' in 'TrackEntry' possible. Found {}", content_encodings.len()))? }
        let content_encodings = content_encodings.pop_front();

        Ok((Self{
            size,

            track_number,
            track_uid,
            track_type,
            flag_enabled,
            flag_default,
            flag_forced,
            flag_hearing_impaired,
            flag_visual_impaired,
            flag_text_descriptions,
            flag_original,
            flag_commentary,
            flag_lacing,
            min_cache,
            max_cache,
            default_duration,
            default_decoded_field_duration,
            track_timestamp_scale,
            track_offset,
            max_block_addition_id,
            block_addition_mapping,
            name,
            language,
            language_bcp_47,
            codec_id,
            codec_private,
            codec_name,
            attachment_link,
            codec_settings,
            codec_info_url,
            codec_download_url,
            codec_decode_all,
            track_overlay,
            codec_delay,
            seek_pre_roll,
            track_translate,
            video,
            audio,
            track_operation,
            trick_track_uid,
            trick_track_segment_uid,
            trick_track_flag,
            trick_struct_track_uid,
            trick_struct_track_segment_uid,
            content_encodings,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for BlockAdditionMapping {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::BlockAdditionMapping { return Err(anyhow::anyhow!("BlockAdditionMapping not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'BlockAdditionMapping' unknown data size is not allowed")),
        };
        let mut block_add_id_value: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut block_add_id_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut block_add_id_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut block_add_id_extra_data: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::BlockAddIdValue => {
                    let size = size.try_sized(EbmlId::BlockAddIdValue)?;
                    block_add_id_value.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockAddIdName => {
                    let size = size.try_sized(EbmlId::BlockAddIdName)?;
                    block_add_id_name.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockAddIdType => {
                    let size = size.try_sized(EbmlId::BlockAddIdType)?;
                    block_add_id_type.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BlockAddIdExtraData => {
                    let size = size.try_sized(EbmlId::BlockAddIdExtraData)?;
                    block_add_id_extra_data.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'BlockAdditionMapping'", id))?,
            }
            index += 1;
        }

        if block_add_id_value.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAddIdValue' in 'BlockAdditionMapping' possible. Found {}", block_add_id_value.len()))? }
        let block_add_id_value = block_add_id_value.pop_front();
        if block_add_id_name.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAddIdName' in 'BlockAdditionMapping' possible. Found {}", block_add_id_name.len()))? }
        let block_add_id_name = block_add_id_name.pop_front();
        if block_add_id_type.len() == 0 { block_add_id_type.push_back(Ebml::new(0)); }
        if block_add_id_type.len() != 1 { Err(anyhow::anyhow!("One element 'BlockAddIdType' must be in 'BlockAdditionMapping'. Found {}", block_add_id_type.len()))? }
        let block_add_id_type = block_add_id_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'BlockAddIdType' doesn't exist in 'BlockAdditionMapping'"))?;
        if block_add_id_extra_data.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAddIdExtraData' in 'BlockAdditionMapping' possible. Found {}", block_add_id_extra_data.len()))? }
        let block_add_id_extra_data = block_add_id_extra_data.pop_front();

        Ok((Self{
            size,

            block_add_id_value,
            block_add_id_name,
            block_add_id_type,
            block_add_id_extra_data,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for BlockAdditionMapping {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::BlockAdditionMapping { return Err(anyhow::anyhow!("BlockAdditionMapping not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'BlockAdditionMapping' unknown data size is not allowed")),
        };
        let mut block_add_id_value: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut block_add_id_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut block_add_id_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut block_add_id_extra_data: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::BlockAddIdValue => {
                    let size = size.try_sized(EbmlId::BlockAddIdValue)?;
                    block_add_id_value.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockAddIdName => {
                    let size = size.try_sized(EbmlId::BlockAddIdName)?;
                    block_add_id_name.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockAddIdType => {
                    let size = size.try_sized(EbmlId::BlockAddIdType)?;
                    block_add_id_type.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BlockAddIdExtraData => {
                    let size = size.try_sized(EbmlId::BlockAddIdExtraData)?;
                    block_add_id_extra_data.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'BlockAdditionMapping'", id))?,
            }
            index += 1;
        }

        if block_add_id_value.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAddIdValue' in 'BlockAdditionMapping' possible. Found {}", block_add_id_value.len()))? }
        let block_add_id_value = block_add_id_value.pop_front();
        if block_add_id_name.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAddIdName' in 'BlockAdditionMapping' possible. Found {}", block_add_id_name.len()))? }
        let block_add_id_name = block_add_id_name.pop_front();
        if block_add_id_type.len() == 0 { block_add_id_type.push_back(Ebml::new(0)); }
        if block_add_id_type.len() != 1 { Err(anyhow::anyhow!("One element 'BlockAddIdType' must be in 'BlockAdditionMapping'. Found {}", block_add_id_type.len()))? }
        let block_add_id_type = block_add_id_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'BlockAddIdType' doesn't exist in 'BlockAdditionMapping'"))?;
        if block_add_id_extra_data.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BlockAddIdExtraData' in 'BlockAdditionMapping' possible. Found {}", block_add_id_extra_data.len()))? }
        let block_add_id_extra_data = block_add_id_extra_data.pop_front();

        Ok((Self{
            size,

            block_add_id_value,
            block_add_id_name,
            block_add_id_type,
            block_add_id_extra_data,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for TrackTranslate {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::TrackTranslate { return Err(anyhow::anyhow!("TrackTranslate not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackTranslate' unknown data size is not allowed")),
        };
        let mut track_translate_track_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut track_translate_codec: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_translate_edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackTranslateTrackId => {
                    let size = size.try_sized(EbmlId::TrackTranslateTrackId)?;
                    track_translate_track_id.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackTranslateCodec => {
                    let size = size.try_sized(EbmlId::TrackTranslateCodec)?;
                    track_translate_codec.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackTranslateEditionUid => {
                    let size = size.try_sized(EbmlId::TrackTranslateEditionUid)?;
                    track_translate_edition_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackTranslate'", id))?,
            }
            index += 1;
        }

        if track_translate_track_id.len() != 1 { Err(anyhow::anyhow!("One element 'TrackTranslateTrackId' must be in 'TrackTranslate'. Found {}", track_translate_track_id.len()))? }
        let track_translate_track_id = track_translate_track_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackTranslateTrackId' doesn't exist in 'TrackTranslate'"))?;
        if track_translate_codec.len() != 1 { Err(anyhow::anyhow!("One element 'TrackTranslateCodec' must be in 'TrackTranslate'. Found {}", track_translate_codec.len()))? }
        let track_translate_codec = track_translate_codec.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackTranslateCodec' doesn't exist in 'TrackTranslate'"))?;
        let track_translate_edition_uid = Vec::from(track_translate_edition_uid);

        Ok((Self{
            size,

            track_translate_track_id,
            track_translate_codec,
            track_translate_edition_uid,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for TrackTranslate {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::TrackTranslate { return Err(anyhow::anyhow!("TrackTranslate not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackTranslate' unknown data size is not allowed")),
        };
        let mut track_translate_track_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut track_translate_codec: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_translate_edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackTranslateTrackId => {
                    let size = size.try_sized(EbmlId::TrackTranslateTrackId)?;
                    track_translate_track_id.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackTranslateCodec => {
                    let size = size.try_sized(EbmlId::TrackTranslateCodec)?;
                    track_translate_codec.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackTranslateEditionUid => {
                    let size = size.try_sized(EbmlId::TrackTranslateEditionUid)?;
                    track_translate_edition_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackTranslate'", id))?,
            }
            index += 1;
        }

        if track_translate_track_id.len() != 1 { Err(anyhow::anyhow!("One element 'TrackTranslateTrackId' must be in 'TrackTranslate'. Found {}", track_translate_track_id.len()))? }
        let track_translate_track_id = track_translate_track_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackTranslateTrackId' doesn't exist in 'TrackTranslate'"))?;
        if track_translate_codec.len() != 1 { Err(anyhow::anyhow!("One element 'TrackTranslateCodec' must be in 'TrackTranslate'. Found {}", track_translate_codec.len()))? }
        let track_translate_codec = track_translate_codec.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackTranslateCodec' doesn't exist in 'TrackTranslate'"))?;
        let track_translate_edition_uid = Vec::from(track_translate_edition_uid);

        Ok((Self{
            size,

            track_translate_track_id,
            track_translate_codec,
            track_translate_edition_uid,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Video {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Video { return Err(anyhow::anyhow!("Video not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Video' unknown data size is not allowed")),
        };
        let mut flag_interlaced: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut field_order: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut stereo_mode: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut alpha_mode: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut old_stereo_mode: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_width: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_height: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_crop_bottom: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_crop_top: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_crop_left: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_crop_right: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut display_width: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut display_height: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut display_unit: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut aspect_ratio_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut uncompressed_four_cc: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut gamma_value: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut frame_rate: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut colour: VecDeque<Ebml<Colour>> = VecDeque::new();
        let mut projection: VecDeque<Ebml<Projection>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::FlagInterlaced => {
                    let size = size.try_sized(EbmlId::FlagInterlaced)?;
                    flag_interlaced.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FieldOrder => {
                    let size = size.try_sized(EbmlId::FieldOrder)?;
                    field_order.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::StereoMode => {
                    let size = size.try_sized(EbmlId::StereoMode)?;
                    stereo_mode.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::AlphaMode => {
                    let size = size.try_sized(EbmlId::AlphaMode)?;
                    alpha_mode.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::OldStereoMode => {
                    let size = size.try_sized(EbmlId::OldStereoMode)?;
                    old_stereo_mode.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PixelWidth => {
                    let size = size.try_sized(EbmlId::PixelWidth)?;
                    pixel_width.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PixelHeight => {
                    let size = size.try_sized(EbmlId::PixelHeight)?;
                    pixel_height.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PixelCropBottom => {
                    let size = size.try_sized(EbmlId::PixelCropBottom)?;
                    pixel_crop_bottom.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PixelCropTop => {
                    let size = size.try_sized(EbmlId::PixelCropTop)?;
                    pixel_crop_top.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PixelCropLeft => {
                    let size = size.try_sized(EbmlId::PixelCropLeft)?;
                    pixel_crop_left.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PixelCropRight => {
                    let size = size.try_sized(EbmlId::PixelCropRight)?;
                    pixel_crop_right.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DisplayWidth => {
                    let size = size.try_sized(EbmlId::DisplayWidth)?;
                    display_width.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DisplayHeight => {
                    let size = size.try_sized(EbmlId::DisplayHeight)?;
                    display_height.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::DisplayUnit => {
                    let size = size.try_sized(EbmlId::DisplayUnit)?;
                    display_unit.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::AspectRatioType => {
                    let size = size.try_sized(EbmlId::AspectRatioType)?;
                    aspect_ratio_type.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::UncompressedFourCc => {
                    let size = size.try_sized(EbmlId::UncompressedFourCc)?;
                    uncompressed_four_cc.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::GammaValue => {
                    let size = size.try_sized(EbmlId::GammaValue)?;
                    gamma_value.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FrameRate => {
                    let size = size.try_sized(EbmlId::FrameRate)?;
                    frame_rate.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Colour => {
                    let (val, read) = Colour::read_body(r, size)?;
                    colour.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Projection => {
                    let (val, read) = Projection::read_body(r, size)?;
                    projection.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Video'", id))?,
            }
            index += 1;
        }

        if flag_interlaced.len() == 0 { flag_interlaced.push_back(Ebml::new(0)); }
        if flag_interlaced.len() != 1 { Err(anyhow::anyhow!("One element 'FlagInterlaced' must be in 'Video'. Found {}", flag_interlaced.len()))? }
        let flag_interlaced = flag_interlaced.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagInterlaced' doesn't exist in 'Video'"))?;
        if field_order.len() == 0 { field_order.push_back(Ebml::new(2)); }
        if field_order.len() != 1 { Err(anyhow::anyhow!("One element 'FieldOrder' must be in 'Video'. Found {}", field_order.len()))? }
        let field_order = field_order.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FieldOrder' doesn't exist in 'Video'"))?;
        if stereo_mode.len() == 0 { stereo_mode.push_back(Ebml::new(0)); }
        if stereo_mode.len() != 1 { Err(anyhow::anyhow!("One element 'StereoMode' must be in 'Video'. Found {}", stereo_mode.len()))? }
        let stereo_mode = stereo_mode.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'StereoMode' doesn't exist in 'Video'"))?;
        if alpha_mode.len() == 0 { alpha_mode.push_back(Ebml::new(0)); }
        if alpha_mode.len() != 1 { Err(anyhow::anyhow!("One element 'AlphaMode' must be in 'Video'. Found {}", alpha_mode.len()))? }
        let alpha_mode = alpha_mode.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'AlphaMode' doesn't exist in 'Video'"))?;
        if old_stereo_mode.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'OldStereoMode' in 'Video' possible. Found {}", old_stereo_mode.len()))? }
        let old_stereo_mode = old_stereo_mode.pop_front();
        if pixel_width.len() != 1 { Err(anyhow::anyhow!("One element 'PixelWidth' must be in 'Video'. Found {}", pixel_width.len()))? }
        let pixel_width = pixel_width.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelWidth' doesn't exist in 'Video'"))?;
        if pixel_height.len() != 1 { Err(anyhow::anyhow!("One element 'PixelHeight' must be in 'Video'. Found {}", pixel_height.len()))? }
        let pixel_height = pixel_height.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelHeight' doesn't exist in 'Video'"))?;
        if pixel_crop_bottom.len() == 0 { pixel_crop_bottom.push_back(Ebml::new(0)); }
        if pixel_crop_bottom.len() != 1 { Err(anyhow::anyhow!("One element 'PixelCropBottom' must be in 'Video'. Found {}", pixel_crop_bottom.len()))? }
        let pixel_crop_bottom = pixel_crop_bottom.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelCropBottom' doesn't exist in 'Video'"))?;
        if pixel_crop_top.len() == 0 { pixel_crop_top.push_back(Ebml::new(0)); }
        if pixel_crop_top.len() != 1 { Err(anyhow::anyhow!("One element 'PixelCropTop' must be in 'Video'. Found {}", pixel_crop_top.len()))? }
        let pixel_crop_top = pixel_crop_top.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelCropTop' doesn't exist in 'Video'"))?;
        if pixel_crop_left.len() == 0 { pixel_crop_left.push_back(Ebml::new(0)); }
        if pixel_crop_left.len() != 1 { Err(anyhow::anyhow!("One element 'PixelCropLeft' must be in 'Video'. Found {}", pixel_crop_left.len()))? }
        let pixel_crop_left = pixel_crop_left.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelCropLeft' doesn't exist in 'Video'"))?;
        if pixel_crop_right.len() == 0 { pixel_crop_right.push_back(Ebml::new(0)); }
        if pixel_crop_right.len() != 1 { Err(anyhow::anyhow!("One element 'PixelCropRight' must be in 'Video'. Found {}", pixel_crop_right.len()))? }
        let pixel_crop_right = pixel_crop_right.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelCropRight' doesn't exist in 'Video'"))?;
        if display_width.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DisplayWidth' in 'Video' possible. Found {}", display_width.len()))? }
        let display_width = display_width.pop_front();
        if display_height.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DisplayHeight' in 'Video' possible. Found {}", display_height.len()))? }
        let display_height = display_height.pop_front();
        if display_unit.len() == 0 { display_unit.push_back(Ebml::new(0)); }
        if display_unit.len() != 1 { Err(anyhow::anyhow!("One element 'DisplayUnit' must be in 'Video'. Found {}", display_unit.len()))? }
        let display_unit = display_unit.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'DisplayUnit' doesn't exist in 'Video'"))?;
        if aspect_ratio_type.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'AspectRatioType' in 'Video' possible. Found {}", aspect_ratio_type.len()))? }
        let aspect_ratio_type = aspect_ratio_type.pop_front();
        if uncompressed_four_cc.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'UncompressedFourCc' in 'Video' possible. Found {}", uncompressed_four_cc.len()))? }
        let uncompressed_four_cc = uncompressed_four_cc.pop_front();
        if gamma_value.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'GammaValue' in 'Video' possible. Found {}", gamma_value.len()))? }
        let gamma_value = gamma_value.pop_front();
        if frame_rate.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FrameRate' in 'Video' possible. Found {}", frame_rate.len()))? }
        let frame_rate = frame_rate.pop_front();
        if colour.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Colour' in 'Video' possible. Found {}", colour.len()))? }
        let colour = colour.pop_front();
        if projection.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Projection' in 'Video' possible. Found {}", projection.len()))? }
        let projection = projection.pop_front();

        Ok((Self{
            size,

            flag_interlaced,
            field_order,
            stereo_mode,
            alpha_mode,
            old_stereo_mode,
            pixel_width,
            pixel_height,
            pixel_crop_bottom,
            pixel_crop_top,
            pixel_crop_left,
            pixel_crop_right,
            display_width,
            display_height,
            display_unit,
            aspect_ratio_type,
            uncompressed_four_cc,
            gamma_value,
            frame_rate,
            colour,
            projection,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Video {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Video { return Err(anyhow::anyhow!("Video not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Video' unknown data size is not allowed")),
        };
        let mut flag_interlaced: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut field_order: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut stereo_mode: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut alpha_mode: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut old_stereo_mode: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_width: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_height: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_crop_bottom: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_crop_top: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_crop_left: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut pixel_crop_right: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut display_width: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut display_height: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut display_unit: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut aspect_ratio_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut uncompressed_four_cc: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut gamma_value: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut frame_rate: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut colour: VecDeque<Ebml<Colour>> = VecDeque::new();
        let mut projection: VecDeque<Ebml<Projection>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::FlagInterlaced => {
                    let size = size.try_sized(EbmlId::FlagInterlaced)?;
                    flag_interlaced.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FieldOrder => {
                    let size = size.try_sized(EbmlId::FieldOrder)?;
                    field_order.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::StereoMode => {
                    let size = size.try_sized(EbmlId::StereoMode)?;
                    stereo_mode.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::AlphaMode => {
                    let size = size.try_sized(EbmlId::AlphaMode)?;
                    alpha_mode.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::OldStereoMode => {
                    let size = size.try_sized(EbmlId::OldStereoMode)?;
                    old_stereo_mode.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PixelWidth => {
                    let size = size.try_sized(EbmlId::PixelWidth)?;
                    pixel_width.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PixelHeight => {
                    let size = size.try_sized(EbmlId::PixelHeight)?;
                    pixel_height.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PixelCropBottom => {
                    let size = size.try_sized(EbmlId::PixelCropBottom)?;
                    pixel_crop_bottom.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PixelCropTop => {
                    let size = size.try_sized(EbmlId::PixelCropTop)?;
                    pixel_crop_top.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PixelCropLeft => {
                    let size = size.try_sized(EbmlId::PixelCropLeft)?;
                    pixel_crop_left.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PixelCropRight => {
                    let size = size.try_sized(EbmlId::PixelCropRight)?;
                    pixel_crop_right.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DisplayWidth => {
                    let size = size.try_sized(EbmlId::DisplayWidth)?;
                    display_width.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DisplayHeight => {
                    let size = size.try_sized(EbmlId::DisplayHeight)?;
                    display_height.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::DisplayUnit => {
                    let size = size.try_sized(EbmlId::DisplayUnit)?;
                    display_unit.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::AspectRatioType => {
                    let size = size.try_sized(EbmlId::AspectRatioType)?;
                    aspect_ratio_type.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::UncompressedFourCc => {
                    let size = size.try_sized(EbmlId::UncompressedFourCc)?;
                    uncompressed_four_cc.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::GammaValue => {
                    let size = size.try_sized(EbmlId::GammaValue)?;
                    gamma_value.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FrameRate => {
                    let size = size.try_sized(EbmlId::FrameRate)?;
                    frame_rate.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Colour => {
                    let (val, read) = Colour::read_body(r, size).await?;
                    colour.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::Projection => {
                    let (val, read) = Projection::read_body(r, size).await?;
                    projection.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Video'", id))?,
            }
            index += 1;
        }

        if flag_interlaced.len() == 0 { flag_interlaced.push_back(Ebml::new(0)); }
        if flag_interlaced.len() != 1 { Err(anyhow::anyhow!("One element 'FlagInterlaced' must be in 'Video'. Found {}", flag_interlaced.len()))? }
        let flag_interlaced = flag_interlaced.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FlagInterlaced' doesn't exist in 'Video'"))?;
        if field_order.len() == 0 { field_order.push_back(Ebml::new(2)); }
        if field_order.len() != 1 { Err(anyhow::anyhow!("One element 'FieldOrder' must be in 'Video'. Found {}", field_order.len()))? }
        let field_order = field_order.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FieldOrder' doesn't exist in 'Video'"))?;
        if stereo_mode.len() == 0 { stereo_mode.push_back(Ebml::new(0)); }
        if stereo_mode.len() != 1 { Err(anyhow::anyhow!("One element 'StereoMode' must be in 'Video'. Found {}", stereo_mode.len()))? }
        let stereo_mode = stereo_mode.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'StereoMode' doesn't exist in 'Video'"))?;
        if alpha_mode.len() == 0 { alpha_mode.push_back(Ebml::new(0)); }
        if alpha_mode.len() != 1 { Err(anyhow::anyhow!("One element 'AlphaMode' must be in 'Video'. Found {}", alpha_mode.len()))? }
        let alpha_mode = alpha_mode.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'AlphaMode' doesn't exist in 'Video'"))?;
        if old_stereo_mode.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'OldStereoMode' in 'Video' possible. Found {}", old_stereo_mode.len()))? }
        let old_stereo_mode = old_stereo_mode.pop_front();
        if pixel_width.len() != 1 { Err(anyhow::anyhow!("One element 'PixelWidth' must be in 'Video'. Found {}", pixel_width.len()))? }
        let pixel_width = pixel_width.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelWidth' doesn't exist in 'Video'"))?;
        if pixel_height.len() != 1 { Err(anyhow::anyhow!("One element 'PixelHeight' must be in 'Video'. Found {}", pixel_height.len()))? }
        let pixel_height = pixel_height.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelHeight' doesn't exist in 'Video'"))?;
        if pixel_crop_bottom.len() == 0 { pixel_crop_bottom.push_back(Ebml::new(0)); }
        if pixel_crop_bottom.len() != 1 { Err(anyhow::anyhow!("One element 'PixelCropBottom' must be in 'Video'. Found {}", pixel_crop_bottom.len()))? }
        let pixel_crop_bottom = pixel_crop_bottom.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelCropBottom' doesn't exist in 'Video'"))?;
        if pixel_crop_top.len() == 0 { pixel_crop_top.push_back(Ebml::new(0)); }
        if pixel_crop_top.len() != 1 { Err(anyhow::anyhow!("One element 'PixelCropTop' must be in 'Video'. Found {}", pixel_crop_top.len()))? }
        let pixel_crop_top = pixel_crop_top.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelCropTop' doesn't exist in 'Video'"))?;
        if pixel_crop_left.len() == 0 { pixel_crop_left.push_back(Ebml::new(0)); }
        if pixel_crop_left.len() != 1 { Err(anyhow::anyhow!("One element 'PixelCropLeft' must be in 'Video'. Found {}", pixel_crop_left.len()))? }
        let pixel_crop_left = pixel_crop_left.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelCropLeft' doesn't exist in 'Video'"))?;
        if pixel_crop_right.len() == 0 { pixel_crop_right.push_back(Ebml::new(0)); }
        if pixel_crop_right.len() != 1 { Err(anyhow::anyhow!("One element 'PixelCropRight' must be in 'Video'. Found {}", pixel_crop_right.len()))? }
        let pixel_crop_right = pixel_crop_right.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'PixelCropRight' doesn't exist in 'Video'"))?;
        if display_width.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DisplayWidth' in 'Video' possible. Found {}", display_width.len()))? }
        let display_width = display_width.pop_front();
        if display_height.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'DisplayHeight' in 'Video' possible. Found {}", display_height.len()))? }
        let display_height = display_height.pop_front();
        if display_unit.len() == 0 { display_unit.push_back(Ebml::new(0)); }
        if display_unit.len() != 1 { Err(anyhow::anyhow!("One element 'DisplayUnit' must be in 'Video'. Found {}", display_unit.len()))? }
        let display_unit = display_unit.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'DisplayUnit' doesn't exist in 'Video'"))?;
        if aspect_ratio_type.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'AspectRatioType' in 'Video' possible. Found {}", aspect_ratio_type.len()))? }
        let aspect_ratio_type = aspect_ratio_type.pop_front();
        if uncompressed_four_cc.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'UncompressedFourCc' in 'Video' possible. Found {}", uncompressed_four_cc.len()))? }
        let uncompressed_four_cc = uncompressed_four_cc.pop_front();
        if gamma_value.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'GammaValue' in 'Video' possible. Found {}", gamma_value.len()))? }
        let gamma_value = gamma_value.pop_front();
        if frame_rate.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FrameRate' in 'Video' possible. Found {}", frame_rate.len()))? }
        let frame_rate = frame_rate.pop_front();
        if colour.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Colour' in 'Video' possible. Found {}", colour.len()))? }
        let colour = colour.pop_front();
        if projection.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'Projection' in 'Video' possible. Found {}", projection.len()))? }
        let projection = projection.pop_front();

        Ok((Self{
            size,

            flag_interlaced,
            field_order,
            stereo_mode,
            alpha_mode,
            old_stereo_mode,
            pixel_width,
            pixel_height,
            pixel_crop_bottom,
            pixel_crop_top,
            pixel_crop_left,
            pixel_crop_right,
            display_width,
            display_height,
            display_unit,
            aspect_ratio_type,
            uncompressed_four_cc,
            gamma_value,
            frame_rate,
            colour,
            projection,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Colour {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Colour { return Err(anyhow::anyhow!("Colour not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Colour' unknown data size is not allowed")),
        };
        let mut matrix_coefficients: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut bits_per_channel: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chroma_subsampling_horz: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chroma_subsampling_vert: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cb_subsampling_horz: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cb_subsampling_vert: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chroma_siting_horz: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chroma_siting_vert: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut range: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut transfer_characteristics: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut primaries: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut max_cll: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut max_fall: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut structing_metadata: VecDeque<Ebml<StructingMetadata>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::MatrixCoefficients => {
                    let size = size.try_sized(EbmlId::MatrixCoefficients)?;
                    matrix_coefficients.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BitsPerChannel => {
                    let size = size.try_sized(EbmlId::BitsPerChannel)?;
                    bits_per_channel.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChromaSubsamplingHorz => {
                    let size = size.try_sized(EbmlId::ChromaSubsamplingHorz)?;
                    chroma_subsampling_horz.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChromaSubsamplingVert => {
                    let size = size.try_sized(EbmlId::ChromaSubsamplingVert)?;
                    chroma_subsampling_vert.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CbSubsamplingHorz => {
                    let size = size.try_sized(EbmlId::CbSubsamplingHorz)?;
                    cb_subsampling_horz.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CbSubsamplingVert => {
                    let size = size.try_sized(EbmlId::CbSubsamplingVert)?;
                    cb_subsampling_vert.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChromaSitingHorz => {
                    let size = size.try_sized(EbmlId::ChromaSitingHorz)?;
                    chroma_siting_horz.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChromaSitingVert => {
                    let size = size.try_sized(EbmlId::ChromaSitingVert)?;
                    chroma_siting_vert.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Range => {
                    let size = size.try_sized(EbmlId::Range)?;
                    range.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TransferCharacteristics => {
                    let size = size.try_sized(EbmlId::TransferCharacteristics)?;
                    transfer_characteristics.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Primaries => {
                    let size = size.try_sized(EbmlId::Primaries)?;
                    primaries.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::MaxCll => {
                    let size = size.try_sized(EbmlId::MaxCll)?;
                    max_cll.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::MaxFall => {
                    let size = size.try_sized(EbmlId::MaxFall)?;
                    max_fall.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::StructingMetadata => {
                    let (val, read) = StructingMetadata::read_body(r, size)?;
                    structing_metadata.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Colour'", id))?,
            }
            index += 1;
        }

        if matrix_coefficients.len() == 0 { matrix_coefficients.push_back(Ebml::new(2)); }
        if matrix_coefficients.len() != 1 { Err(anyhow::anyhow!("One element 'MatrixCoefficients' must be in 'Colour'. Found {}", matrix_coefficients.len()))? }
        let matrix_coefficients = matrix_coefficients.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'MatrixCoefficients' doesn't exist in 'Colour'"))?;
        if bits_per_channel.len() == 0 { bits_per_channel.push_back(Ebml::new(0)); }
        if bits_per_channel.len() != 1 { Err(anyhow::anyhow!("One element 'BitsPerChannel' must be in 'Colour'. Found {}", bits_per_channel.len()))? }
        let bits_per_channel = bits_per_channel.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'BitsPerChannel' doesn't exist in 'Colour'"))?;
        if chroma_subsampling_horz.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChromaSubsamplingHorz' in 'Colour' possible. Found {}", chroma_subsampling_horz.len()))? }
        let chroma_subsampling_horz = chroma_subsampling_horz.pop_front();
        if chroma_subsampling_vert.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChromaSubsamplingVert' in 'Colour' possible. Found {}", chroma_subsampling_vert.len()))? }
        let chroma_subsampling_vert = chroma_subsampling_vert.pop_front();
        if cb_subsampling_horz.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CbSubsamplingHorz' in 'Colour' possible. Found {}", cb_subsampling_horz.len()))? }
        let cb_subsampling_horz = cb_subsampling_horz.pop_front();
        if cb_subsampling_vert.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CbSubsamplingVert' in 'Colour' possible. Found {}", cb_subsampling_vert.len()))? }
        let cb_subsampling_vert = cb_subsampling_vert.pop_front();
        if chroma_siting_horz.len() == 0 { chroma_siting_horz.push_back(Ebml::new(0)); }
        if chroma_siting_horz.len() != 1 { Err(anyhow::anyhow!("One element 'ChromaSitingHorz' must be in 'Colour'. Found {}", chroma_siting_horz.len()))? }
        let chroma_siting_horz = chroma_siting_horz.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChromaSitingHorz' doesn't exist in 'Colour'"))?;
        if chroma_siting_vert.len() == 0 { chroma_siting_vert.push_back(Ebml::new(0)); }
        if chroma_siting_vert.len() != 1 { Err(anyhow::anyhow!("One element 'ChromaSitingVert' must be in 'Colour'. Found {}", chroma_siting_vert.len()))? }
        let chroma_siting_vert = chroma_siting_vert.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChromaSitingVert' doesn't exist in 'Colour'"))?;
        if range.len() == 0 { range.push_back(Ebml::new(0)); }
        if range.len() != 1 { Err(anyhow::anyhow!("One element 'Range' must be in 'Colour'. Found {}", range.len()))? }
        let range = range.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Range' doesn't exist in 'Colour'"))?;
        if transfer_characteristics.len() == 0 { transfer_characteristics.push_back(Ebml::new(2)); }
        if transfer_characteristics.len() != 1 { Err(anyhow::anyhow!("One element 'TransferCharacteristics' must be in 'Colour'. Found {}", transfer_characteristics.len()))? }
        let transfer_characteristics = transfer_characteristics.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TransferCharacteristics' doesn't exist in 'Colour'"))?;
        if primaries.len() == 0 { primaries.push_back(Ebml::new(2)); }
        if primaries.len() != 1 { Err(anyhow::anyhow!("One element 'Primaries' must be in 'Colour'. Found {}", primaries.len()))? }
        let primaries = primaries.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Primaries' doesn't exist in 'Colour'"))?;
        if max_cll.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'MaxCll' in 'Colour' possible. Found {}", max_cll.len()))? }
        let max_cll = max_cll.pop_front();
        if max_fall.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'MaxFall' in 'Colour' possible. Found {}", max_fall.len()))? }
        let max_fall = max_fall.pop_front();
        if structing_metadata.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'StructingMetadata' in 'Colour' possible. Found {}", structing_metadata.len()))? }
        let structing_metadata = structing_metadata.pop_front();

        Ok((Self{
            size,

            matrix_coefficients,
            bits_per_channel,
            chroma_subsampling_horz,
            chroma_subsampling_vert,
            cb_subsampling_horz,
            cb_subsampling_vert,
            chroma_siting_horz,
            chroma_siting_vert,
            range,
            transfer_characteristics,
            primaries,
            max_cll,
            max_fall,
            structing_metadata,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Colour {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Colour { return Err(anyhow::anyhow!("Colour not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Colour' unknown data size is not allowed")),
        };
        let mut matrix_coefficients: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut bits_per_channel: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chroma_subsampling_horz: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chroma_subsampling_vert: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cb_subsampling_horz: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cb_subsampling_vert: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chroma_siting_horz: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chroma_siting_vert: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut range: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut transfer_characteristics: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut primaries: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut max_cll: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut max_fall: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut structing_metadata: VecDeque<Ebml<StructingMetadata>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::MatrixCoefficients => {
                    let size = size.try_sized(EbmlId::MatrixCoefficients)?;
                    matrix_coefficients.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BitsPerChannel => {
                    let size = size.try_sized(EbmlId::BitsPerChannel)?;
                    bits_per_channel.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChromaSubsamplingHorz => {
                    let size = size.try_sized(EbmlId::ChromaSubsamplingHorz)?;
                    chroma_subsampling_horz.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChromaSubsamplingVert => {
                    let size = size.try_sized(EbmlId::ChromaSubsamplingVert)?;
                    chroma_subsampling_vert.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CbSubsamplingHorz => {
                    let size = size.try_sized(EbmlId::CbSubsamplingHorz)?;
                    cb_subsampling_horz.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CbSubsamplingVert => {
                    let size = size.try_sized(EbmlId::CbSubsamplingVert)?;
                    cb_subsampling_vert.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChromaSitingHorz => {
                    let size = size.try_sized(EbmlId::ChromaSitingHorz)?;
                    chroma_siting_horz.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChromaSitingVert => {
                    let size = size.try_sized(EbmlId::ChromaSitingVert)?;
                    chroma_siting_vert.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Range => {
                    let size = size.try_sized(EbmlId::Range)?;
                    range.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TransferCharacteristics => {
                    let size = size.try_sized(EbmlId::TransferCharacteristics)?;
                    transfer_characteristics.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Primaries => {
                    let size = size.try_sized(EbmlId::Primaries)?;
                    primaries.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::MaxCll => {
                    let size = size.try_sized(EbmlId::MaxCll)?;
                    max_cll.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::MaxFall => {
                    let size = size.try_sized(EbmlId::MaxFall)?;
                    max_fall.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::StructingMetadata => {
                    let (val, read) = StructingMetadata::read_body(r, size).await?;
                    structing_metadata.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Colour'", id))?,
            }
            index += 1;
        }

        if matrix_coefficients.len() == 0 { matrix_coefficients.push_back(Ebml::new(2)); }
        if matrix_coefficients.len() != 1 { Err(anyhow::anyhow!("One element 'MatrixCoefficients' must be in 'Colour'. Found {}", matrix_coefficients.len()))? }
        let matrix_coefficients = matrix_coefficients.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'MatrixCoefficients' doesn't exist in 'Colour'"))?;
        if bits_per_channel.len() == 0 { bits_per_channel.push_back(Ebml::new(0)); }
        if bits_per_channel.len() != 1 { Err(anyhow::anyhow!("One element 'BitsPerChannel' must be in 'Colour'. Found {}", bits_per_channel.len()))? }
        let bits_per_channel = bits_per_channel.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'BitsPerChannel' doesn't exist in 'Colour'"))?;
        if chroma_subsampling_horz.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChromaSubsamplingHorz' in 'Colour' possible. Found {}", chroma_subsampling_horz.len()))? }
        let chroma_subsampling_horz = chroma_subsampling_horz.pop_front();
        if chroma_subsampling_vert.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChromaSubsamplingVert' in 'Colour' possible. Found {}", chroma_subsampling_vert.len()))? }
        let chroma_subsampling_vert = chroma_subsampling_vert.pop_front();
        if cb_subsampling_horz.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CbSubsamplingHorz' in 'Colour' possible. Found {}", cb_subsampling_horz.len()))? }
        let cb_subsampling_horz = cb_subsampling_horz.pop_front();
        if cb_subsampling_vert.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CbSubsamplingVert' in 'Colour' possible. Found {}", cb_subsampling_vert.len()))? }
        let cb_subsampling_vert = cb_subsampling_vert.pop_front();
        if chroma_siting_horz.len() == 0 { chroma_siting_horz.push_back(Ebml::new(0)); }
        if chroma_siting_horz.len() != 1 { Err(anyhow::anyhow!("One element 'ChromaSitingHorz' must be in 'Colour'. Found {}", chroma_siting_horz.len()))? }
        let chroma_siting_horz = chroma_siting_horz.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChromaSitingHorz' doesn't exist in 'Colour'"))?;
        if chroma_siting_vert.len() == 0 { chroma_siting_vert.push_back(Ebml::new(0)); }
        if chroma_siting_vert.len() != 1 { Err(anyhow::anyhow!("One element 'ChromaSitingVert' must be in 'Colour'. Found {}", chroma_siting_vert.len()))? }
        let chroma_siting_vert = chroma_siting_vert.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChromaSitingVert' doesn't exist in 'Colour'"))?;
        if range.len() == 0 { range.push_back(Ebml::new(0)); }
        if range.len() != 1 { Err(anyhow::anyhow!("One element 'Range' must be in 'Colour'. Found {}", range.len()))? }
        let range = range.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Range' doesn't exist in 'Colour'"))?;
        if transfer_characteristics.len() == 0 { transfer_characteristics.push_back(Ebml::new(2)); }
        if transfer_characteristics.len() != 1 { Err(anyhow::anyhow!("One element 'TransferCharacteristics' must be in 'Colour'. Found {}", transfer_characteristics.len()))? }
        let transfer_characteristics = transfer_characteristics.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TransferCharacteristics' doesn't exist in 'Colour'"))?;
        if primaries.len() == 0 { primaries.push_back(Ebml::new(2)); }
        if primaries.len() != 1 { Err(anyhow::anyhow!("One element 'Primaries' must be in 'Colour'. Found {}", primaries.len()))? }
        let primaries = primaries.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Primaries' doesn't exist in 'Colour'"))?;
        if max_cll.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'MaxCll' in 'Colour' possible. Found {}", max_cll.len()))? }
        let max_cll = max_cll.pop_front();
        if max_fall.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'MaxFall' in 'Colour' possible. Found {}", max_fall.len()))? }
        let max_fall = max_fall.pop_front();
        if structing_metadata.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'StructingMetadata' in 'Colour' possible. Found {}", structing_metadata.len()))? }
        let structing_metadata = structing_metadata.pop_front();

        Ok((Self{
            size,

            matrix_coefficients,
            bits_per_channel,
            chroma_subsampling_horz,
            chroma_subsampling_vert,
            cb_subsampling_horz,
            cb_subsampling_vert,
            chroma_siting_horz,
            chroma_siting_vert,
            range,
            transfer_characteristics,
            primaries,
            max_cll,
            max_fall,
            structing_metadata,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for StructingMetadata {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::StructingMetadata { return Err(anyhow::anyhow!("StructingMetadata not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'StructingMetadata' unknown data size is not allowed")),
        };
        let mut primary_r_chromaticity_x: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_r_chromaticity_y: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_g_chromaticity_x: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_g_chromaticity_y: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_b_chromaticity_x: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_b_chromaticity_y: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut white_point_chromaticity_x: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut white_point_chromaticity_y: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut luminance_max: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut luminance_min: VecDeque<Ebml<f64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::PrimaryRChromaticityX => {
                    let size = size.try_sized(EbmlId::PrimaryRChromaticityX)?;
                    primary_r_chromaticity_x.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryRChromaticityY => {
                    let size = size.try_sized(EbmlId::PrimaryRChromaticityY)?;
                    primary_r_chromaticity_y.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryGChromaticityX => {
                    let size = size.try_sized(EbmlId::PrimaryGChromaticityX)?;
                    primary_g_chromaticity_x.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryGChromaticityY => {
                    let size = size.try_sized(EbmlId::PrimaryGChromaticityY)?;
                    primary_g_chromaticity_y.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryBChromaticityX => {
                    let size = size.try_sized(EbmlId::PrimaryBChromaticityX)?;
                    primary_b_chromaticity_x.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryBChromaticityY => {
                    let size = size.try_sized(EbmlId::PrimaryBChromaticityY)?;
                    primary_b_chromaticity_y.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::WhitePointChromaticityX => {
                    let size = size.try_sized(EbmlId::WhitePointChromaticityX)?;
                    white_point_chromaticity_x.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::WhitePointChromaticityY => {
                    let size = size.try_sized(EbmlId::WhitePointChromaticityY)?;
                    white_point_chromaticity_y.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::LuminanceMax => {
                    let size = size.try_sized(EbmlId::LuminanceMax)?;
                    luminance_max.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::LuminanceMin => {
                    let size = size.try_sized(EbmlId::LuminanceMin)?;
                    luminance_min.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'StructingMetadata'", id))?,
            }
            index += 1;
        }

        if primary_r_chromaticity_x.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryRChromaticityX' in 'StructingMetadata' possible. Found {}", primary_r_chromaticity_x.len()))? }
        let primary_r_chromaticity_x = primary_r_chromaticity_x.pop_front();
        if primary_r_chromaticity_y.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryRChromaticityY' in 'StructingMetadata' possible. Found {}", primary_r_chromaticity_y.len()))? }
        let primary_r_chromaticity_y = primary_r_chromaticity_y.pop_front();
        if primary_g_chromaticity_x.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryGChromaticityX' in 'StructingMetadata' possible. Found {}", primary_g_chromaticity_x.len()))? }
        let primary_g_chromaticity_x = primary_g_chromaticity_x.pop_front();
        if primary_g_chromaticity_y.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryGChromaticityY' in 'StructingMetadata' possible. Found {}", primary_g_chromaticity_y.len()))? }
        let primary_g_chromaticity_y = primary_g_chromaticity_y.pop_front();
        if primary_b_chromaticity_x.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryBChromaticityX' in 'StructingMetadata' possible. Found {}", primary_b_chromaticity_x.len()))? }
        let primary_b_chromaticity_x = primary_b_chromaticity_x.pop_front();
        if primary_b_chromaticity_y.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryBChromaticityY' in 'StructingMetadata' possible. Found {}", primary_b_chromaticity_y.len()))? }
        let primary_b_chromaticity_y = primary_b_chromaticity_y.pop_front();
        if white_point_chromaticity_x.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'WhitePointChromaticityX' in 'StructingMetadata' possible. Found {}", white_point_chromaticity_x.len()))? }
        let white_point_chromaticity_x = white_point_chromaticity_x.pop_front();
        if white_point_chromaticity_y.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'WhitePointChromaticityY' in 'StructingMetadata' possible. Found {}", white_point_chromaticity_y.len()))? }
        let white_point_chromaticity_y = white_point_chromaticity_y.pop_front();
        if luminance_max.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'LuminanceMax' in 'StructingMetadata' possible. Found {}", luminance_max.len()))? }
        let luminance_max = luminance_max.pop_front();
        if luminance_min.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'LuminanceMin' in 'StructingMetadata' possible. Found {}", luminance_min.len()))? }
        let luminance_min = luminance_min.pop_front();

        Ok((Self{
            size,

            primary_r_chromaticity_x,
            primary_r_chromaticity_y,
            primary_g_chromaticity_x,
            primary_g_chromaticity_y,
            primary_b_chromaticity_x,
            primary_b_chromaticity_y,
            white_point_chromaticity_x,
            white_point_chromaticity_y,
            luminance_max,
            luminance_min,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for StructingMetadata {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::StructingMetadata { return Err(anyhow::anyhow!("StructingMetadata not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'StructingMetadata' unknown data size is not allowed")),
        };
        let mut primary_r_chromaticity_x: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_r_chromaticity_y: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_g_chromaticity_x: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_g_chromaticity_y: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_b_chromaticity_x: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut primary_b_chromaticity_y: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut white_point_chromaticity_x: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut white_point_chromaticity_y: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut luminance_max: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut luminance_min: VecDeque<Ebml<f64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::PrimaryRChromaticityX => {
                    let size = size.try_sized(EbmlId::PrimaryRChromaticityX)?;
                    primary_r_chromaticity_x.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryRChromaticityY => {
                    let size = size.try_sized(EbmlId::PrimaryRChromaticityY)?;
                    primary_r_chromaticity_y.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryGChromaticityX => {
                    let size = size.try_sized(EbmlId::PrimaryGChromaticityX)?;
                    primary_g_chromaticity_x.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryGChromaticityY => {
                    let size = size.try_sized(EbmlId::PrimaryGChromaticityY)?;
                    primary_g_chromaticity_y.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryBChromaticityX => {
                    let size = size.try_sized(EbmlId::PrimaryBChromaticityX)?;
                    primary_b_chromaticity_x.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::PrimaryBChromaticityY => {
                    let size = size.try_sized(EbmlId::PrimaryBChromaticityY)?;
                    primary_b_chromaticity_y.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::WhitePointChromaticityX => {
                    let size = size.try_sized(EbmlId::WhitePointChromaticityX)?;
                    white_point_chromaticity_x.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::WhitePointChromaticityY => {
                    let size = size.try_sized(EbmlId::WhitePointChromaticityY)?;
                    white_point_chromaticity_y.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::LuminanceMax => {
                    let size = size.try_sized(EbmlId::LuminanceMax)?;
                    luminance_max.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::LuminanceMin => {
                    let size = size.try_sized(EbmlId::LuminanceMin)?;
                    luminance_min.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'StructingMetadata'", id))?,
            }
            index += 1;
        }

        if primary_r_chromaticity_x.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryRChromaticityX' in 'StructingMetadata' possible. Found {}", primary_r_chromaticity_x.len()))? }
        let primary_r_chromaticity_x = primary_r_chromaticity_x.pop_front();
        if primary_r_chromaticity_y.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryRChromaticityY' in 'StructingMetadata' possible. Found {}", primary_r_chromaticity_y.len()))? }
        let primary_r_chromaticity_y = primary_r_chromaticity_y.pop_front();
        if primary_g_chromaticity_x.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryGChromaticityX' in 'StructingMetadata' possible. Found {}", primary_g_chromaticity_x.len()))? }
        let primary_g_chromaticity_x = primary_g_chromaticity_x.pop_front();
        if primary_g_chromaticity_y.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryGChromaticityY' in 'StructingMetadata' possible. Found {}", primary_g_chromaticity_y.len()))? }
        let primary_g_chromaticity_y = primary_g_chromaticity_y.pop_front();
        if primary_b_chromaticity_x.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryBChromaticityX' in 'StructingMetadata' possible. Found {}", primary_b_chromaticity_x.len()))? }
        let primary_b_chromaticity_x = primary_b_chromaticity_x.pop_front();
        if primary_b_chromaticity_y.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'PrimaryBChromaticityY' in 'StructingMetadata' possible. Found {}", primary_b_chromaticity_y.len()))? }
        let primary_b_chromaticity_y = primary_b_chromaticity_y.pop_front();
        if white_point_chromaticity_x.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'WhitePointChromaticityX' in 'StructingMetadata' possible. Found {}", white_point_chromaticity_x.len()))? }
        let white_point_chromaticity_x = white_point_chromaticity_x.pop_front();
        if white_point_chromaticity_y.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'WhitePointChromaticityY' in 'StructingMetadata' possible. Found {}", white_point_chromaticity_y.len()))? }
        let white_point_chromaticity_y = white_point_chromaticity_y.pop_front();
        if luminance_max.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'LuminanceMax' in 'StructingMetadata' possible. Found {}", luminance_max.len()))? }
        let luminance_max = luminance_max.pop_front();
        if luminance_min.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'LuminanceMin' in 'StructingMetadata' possible. Found {}", luminance_min.len()))? }
        let luminance_min = luminance_min.pop_front();

        Ok((Self{
            size,

            primary_r_chromaticity_x,
            primary_r_chromaticity_y,
            primary_g_chromaticity_x,
            primary_g_chromaticity_y,
            primary_b_chromaticity_x,
            primary_b_chromaticity_y,
            white_point_chromaticity_x,
            white_point_chromaticity_y,
            luminance_max,
            luminance_min,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Projection {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Projection { return Err(anyhow::anyhow!("Projection not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Projection' unknown data size is not allowed")),
        };
        let mut projection_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut projection_private: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut projection_pose_yaw: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut projection_pose_pitch: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut projection_pose_roll: VecDeque<Ebml<f64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ProjectionType => {
                    let size = size.try_sized(EbmlId::ProjectionType)?;
                    projection_type.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ProjectionPrivate => {
                    let size = size.try_sized(EbmlId::ProjectionPrivate)?;
                    projection_private.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ProjectionPoseYaw => {
                    let size = size.try_sized(EbmlId::ProjectionPoseYaw)?;
                    projection_pose_yaw.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ProjectionPosePitch => {
                    let size = size.try_sized(EbmlId::ProjectionPosePitch)?;
                    projection_pose_pitch.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ProjectionPoseRoll => {
                    let size = size.try_sized(EbmlId::ProjectionPoseRoll)?;
                    projection_pose_roll.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Projection'", id))?,
            }
            index += 1;
        }

        if projection_type.len() == 0 { projection_type.push_back(Ebml::new(0)); }
        if projection_type.len() != 1 { Err(anyhow::anyhow!("One element 'ProjectionType' must be in 'Projection'. Found {}", projection_type.len()))? }
        let projection_type = projection_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ProjectionType' doesn't exist in 'Projection'"))?;
        if projection_private.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ProjectionPrivate' in 'Projection' possible. Found {}", projection_private.len()))? }
        let projection_private = projection_private.pop_front();
        if projection_pose_yaw.len() == 0 { projection_pose_yaw.push_back(Ebml::new(hexf::hexf64!("0x0p+0"))); }
        if projection_pose_yaw.len() != 1 { Err(anyhow::anyhow!("One element 'ProjectionPoseYaw' must be in 'Projection'. Found {}", projection_pose_yaw.len()))? }
        let projection_pose_yaw = projection_pose_yaw.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ProjectionPoseYaw' doesn't exist in 'Projection'"))?;
        if projection_pose_pitch.len() == 0 { projection_pose_pitch.push_back(Ebml::new(hexf::hexf64!("0x0p+0"))); }
        if projection_pose_pitch.len() != 1 { Err(anyhow::anyhow!("One element 'ProjectionPosePitch' must be in 'Projection'. Found {}", projection_pose_pitch.len()))? }
        let projection_pose_pitch = projection_pose_pitch.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ProjectionPosePitch' doesn't exist in 'Projection'"))?;
        if projection_pose_roll.len() == 0 { projection_pose_roll.push_back(Ebml::new(hexf::hexf64!("0x0p+0"))); }
        if projection_pose_roll.len() != 1 { Err(anyhow::anyhow!("One element 'ProjectionPoseRoll' must be in 'Projection'. Found {}", projection_pose_roll.len()))? }
        let projection_pose_roll = projection_pose_roll.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ProjectionPoseRoll' doesn't exist in 'Projection'"))?;

        Ok((Self{
            size,

            projection_type,
            projection_private,
            projection_pose_yaw,
            projection_pose_pitch,
            projection_pose_roll,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Projection {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Projection { return Err(anyhow::anyhow!("Projection not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Projection' unknown data size is not allowed")),
        };
        let mut projection_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut projection_private: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut projection_pose_yaw: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut projection_pose_pitch: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut projection_pose_roll: VecDeque<Ebml<f64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ProjectionType => {
                    let size = size.try_sized(EbmlId::ProjectionType)?;
                    projection_type.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ProjectionPrivate => {
                    let size = size.try_sized(EbmlId::ProjectionPrivate)?;
                    projection_private.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ProjectionPoseYaw => {
                    let size = size.try_sized(EbmlId::ProjectionPoseYaw)?;
                    projection_pose_yaw.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ProjectionPosePitch => {
                    let size = size.try_sized(EbmlId::ProjectionPosePitch)?;
                    projection_pose_pitch.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ProjectionPoseRoll => {
                    let size = size.try_sized(EbmlId::ProjectionPoseRoll)?;
                    projection_pose_roll.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Projection'", id))?,
            }
            index += 1;
        }

        if projection_type.len() == 0 { projection_type.push_back(Ebml::new(0)); }
        if projection_type.len() != 1 { Err(anyhow::anyhow!("One element 'ProjectionType' must be in 'Projection'. Found {}", projection_type.len()))? }
        let projection_type = projection_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ProjectionType' doesn't exist in 'Projection'"))?;
        if projection_private.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ProjectionPrivate' in 'Projection' possible. Found {}", projection_private.len()))? }
        let projection_private = projection_private.pop_front();
        if projection_pose_yaw.len() == 0 { projection_pose_yaw.push_back(Ebml::new(hexf::hexf64!("0x0p+0"))); }
        if projection_pose_yaw.len() != 1 { Err(anyhow::anyhow!("One element 'ProjectionPoseYaw' must be in 'Projection'. Found {}", projection_pose_yaw.len()))? }
        let projection_pose_yaw = projection_pose_yaw.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ProjectionPoseYaw' doesn't exist in 'Projection'"))?;
        if projection_pose_pitch.len() == 0 { projection_pose_pitch.push_back(Ebml::new(hexf::hexf64!("0x0p+0"))); }
        if projection_pose_pitch.len() != 1 { Err(anyhow::anyhow!("One element 'ProjectionPosePitch' must be in 'Projection'. Found {}", projection_pose_pitch.len()))? }
        let projection_pose_pitch = projection_pose_pitch.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ProjectionPosePitch' doesn't exist in 'Projection'"))?;
        if projection_pose_roll.len() == 0 { projection_pose_roll.push_back(Ebml::new(hexf::hexf64!("0x0p+0"))); }
        if projection_pose_roll.len() != 1 { Err(anyhow::anyhow!("One element 'ProjectionPoseRoll' must be in 'Projection'. Found {}", projection_pose_roll.len()))? }
        let projection_pose_roll = projection_pose_roll.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ProjectionPoseRoll' doesn't exist in 'Projection'"))?;

        Ok((Self{
            size,

            projection_type,
            projection_private,
            projection_pose_yaw,
            projection_pose_pitch,
            projection_pose_roll,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Audio {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Audio { return Err(anyhow::anyhow!("Audio not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Audio' unknown data size is not allowed")),
        };
        let mut sampling_frequency: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut output_sampling_frequency: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut channels: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut channel_positions: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut bit_depth: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut emphasis: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::SamplingFrequency => {
                    let size = size.try_sized(EbmlId::SamplingFrequency)?;
                    sampling_frequency.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::OutputSamplingFrequency => {
                    let size = size.try_sized(EbmlId::OutputSamplingFrequency)?;
                    output_sampling_frequency.push_back(Ebml::new_index(index, blocking::read_float(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Channels => {
                    let size = size.try_sized(EbmlId::Channels)?;
                    channels.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChannelPositions => {
                    let size = size.try_sized(EbmlId::ChannelPositions)?;
                    channel_positions.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::BitDepth => {
                    let size = size.try_sized(EbmlId::BitDepth)?;
                    bit_depth.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::Emphasis => {
                    let size = size.try_sized(EbmlId::Emphasis)?;
                    emphasis.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Audio'", id))?,
            }
            index += 1;
        }

        if sampling_frequency.len() == 0 { sampling_frequency.push_back(Ebml::new(hexf::hexf64!("0x1.f4p+12"))); }
        if sampling_frequency.len() != 1 { Err(anyhow::anyhow!("One element 'SamplingFrequency' must be in 'Audio'. Found {}", sampling_frequency.len()))? }
        let sampling_frequency = sampling_frequency.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'SamplingFrequency' doesn't exist in 'Audio'"))?;
        if output_sampling_frequency.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'OutputSamplingFrequency' in 'Audio' possible. Found {}", output_sampling_frequency.len()))? }
        let output_sampling_frequency = output_sampling_frequency.pop_front();
        if channels.len() == 0 { channels.push_back(Ebml::new(1)); }
        if channels.len() != 1 { Err(anyhow::anyhow!("One element 'Channels' must be in 'Audio'. Found {}", channels.len()))? }
        let channels = channels.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Channels' doesn't exist in 'Audio'"))?;
        if channel_positions.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChannelPositions' in 'Audio' possible. Found {}", channel_positions.len()))? }
        let channel_positions = channel_positions.pop_front();
        if bit_depth.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BitDepth' in 'Audio' possible. Found {}", bit_depth.len()))? }
        let bit_depth = bit_depth.pop_front();
        if emphasis.len() == 0 { emphasis.push_back(Ebml::new(0)); }
        if emphasis.len() != 1 { Err(anyhow::anyhow!("One element 'Emphasis' must be in 'Audio'. Found {}", emphasis.len()))? }
        let emphasis = emphasis.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Emphasis' doesn't exist in 'Audio'"))?;

        Ok((Self{
            size,

            sampling_frequency,
            output_sampling_frequency,
            channels,
            channel_positions,
            bit_depth,
            emphasis,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Audio {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Audio { return Err(anyhow::anyhow!("Audio not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Audio' unknown data size is not allowed")),
        };
        let mut sampling_frequency: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut output_sampling_frequency: VecDeque<Ebml<f64>> = VecDeque::new();
        let mut channels: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut channel_positions: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut bit_depth: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut emphasis: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::SamplingFrequency => {
                    let size = size.try_sized(EbmlId::SamplingFrequency)?;
                    sampling_frequency.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::OutputSamplingFrequency => {
                    let size = size.try_sized(EbmlId::OutputSamplingFrequency)?;
                    output_sampling_frequency.push_back(Ebml::new_index(index, async_::read_float(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Channels => {
                    let size = size.try_sized(EbmlId::Channels)?;
                    channels.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChannelPositions => {
                    let size = size.try_sized(EbmlId::ChannelPositions)?;
                    channel_positions.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::BitDepth => {
                    let size = size.try_sized(EbmlId::BitDepth)?;
                    bit_depth.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::Emphasis => {
                    let size = size.try_sized(EbmlId::Emphasis)?;
                    emphasis.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Audio'", id))?,
            }
            index += 1;
        }

        if sampling_frequency.len() == 0 { sampling_frequency.push_back(Ebml::new(hexf::hexf64!("0x1.f4p+12"))); }
        if sampling_frequency.len() != 1 { Err(anyhow::anyhow!("One element 'SamplingFrequency' must be in 'Audio'. Found {}", sampling_frequency.len()))? }
        let sampling_frequency = sampling_frequency.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'SamplingFrequency' doesn't exist in 'Audio'"))?;
        if output_sampling_frequency.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'OutputSamplingFrequency' in 'Audio' possible. Found {}", output_sampling_frequency.len()))? }
        let output_sampling_frequency = output_sampling_frequency.pop_front();
        if channels.len() == 0 { channels.push_back(Ebml::new(1)); }
        if channels.len() != 1 { Err(anyhow::anyhow!("One element 'Channels' must be in 'Audio'. Found {}", channels.len()))? }
        let channels = channels.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Channels' doesn't exist in 'Audio'"))?;
        if channel_positions.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChannelPositions' in 'Audio' possible. Found {}", channel_positions.len()))? }
        let channel_positions = channel_positions.pop_front();
        if bit_depth.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'BitDepth' in 'Audio' possible. Found {}", bit_depth.len()))? }
        let bit_depth = bit_depth.pop_front();
        if emphasis.len() == 0 { emphasis.push_back(Ebml::new(0)); }
        if emphasis.len() != 1 { Err(anyhow::anyhow!("One element 'Emphasis' must be in 'Audio'. Found {}", emphasis.len()))? }
        let emphasis = emphasis.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Emphasis' doesn't exist in 'Audio'"))?;

        Ok((Self{
            size,

            sampling_frequency,
            output_sampling_frequency,
            channels,
            channel_positions,
            bit_depth,
            emphasis,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for TrackOperation {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::TrackOperation { return Err(anyhow::anyhow!("TrackOperation not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackOperation' unknown data size is not allowed")),
        };
        let mut track_combine_planes: VecDeque<Ebml<TrackCombinePlanes>> = VecDeque::new();
        let mut track_join_blocks: VecDeque<Ebml<TrackJoinBlocks>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackCombinePlanes => {
                    let (val, read) = TrackCombinePlanes::read_body(r, size)?;
                    track_combine_planes.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::TrackJoinBlocks => {
                    let (val, read) = TrackJoinBlocks::read_body(r, size)?;
                    track_join_blocks.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackOperation'", id))?,
            }
            index += 1;
        }

        if track_combine_planes.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrackCombinePlanes' in 'TrackOperation' possible. Found {}", track_combine_planes.len()))? }
        let track_combine_planes = track_combine_planes.pop_front();
        if track_join_blocks.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrackJoinBlocks' in 'TrackOperation' possible. Found {}", track_join_blocks.len()))? }
        let track_join_blocks = track_join_blocks.pop_front();

        Ok((Self{
            size,

            track_combine_planes,
            track_join_blocks,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for TrackOperation {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::TrackOperation { return Err(anyhow::anyhow!("TrackOperation not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackOperation' unknown data size is not allowed")),
        };
        let mut track_combine_planes: VecDeque<Ebml<TrackCombinePlanes>> = VecDeque::new();
        let mut track_join_blocks: VecDeque<Ebml<TrackJoinBlocks>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackCombinePlanes => {
                    let (val, read) = TrackCombinePlanes::read_body(r, size).await?;
                    track_combine_planes.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::TrackJoinBlocks => {
                    let (val, read) = TrackJoinBlocks::read_body(r, size).await?;
                    track_join_blocks.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackOperation'", id))?,
            }
            index += 1;
        }

        if track_combine_planes.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrackCombinePlanes' in 'TrackOperation' possible. Found {}", track_combine_planes.len()))? }
        let track_combine_planes = track_combine_planes.pop_front();
        if track_join_blocks.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TrackJoinBlocks' in 'TrackOperation' possible. Found {}", track_join_blocks.len()))? }
        let track_join_blocks = track_join_blocks.pop_front();

        Ok((Self{
            size,

            track_combine_planes,
            track_join_blocks,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for TrackCombinePlanes {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::TrackCombinePlanes { return Err(anyhow::anyhow!("TrackCombinePlanes not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackCombinePlanes' unknown data size is not allowed")),
        };
        let mut track_plane: VecDeque<Ebml<TrackPlane>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackPlane => {
                    let (val, read) = TrackPlane::read_body(r, size)?;
                    track_plane.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackCombinePlanes'", id))?,
            }
            index += 1;
        }

        let track_plane = Vec::from(track_plane);

        Ok((Self{
            size,

            track_plane,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for TrackCombinePlanes {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::TrackCombinePlanes { return Err(anyhow::anyhow!("TrackCombinePlanes not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackCombinePlanes' unknown data size is not allowed")),
        };
        let mut track_plane: VecDeque<Ebml<TrackPlane>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackPlane => {
                    let (val, read) = TrackPlane::read_body(r, size).await?;
                    track_plane.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackCombinePlanes'", id))?,
            }
            index += 1;
        }

        let track_plane = Vec::from(track_plane);

        Ok((Self{
            size,

            track_plane,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for TrackPlane {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::TrackPlane { return Err(anyhow::anyhow!("TrackPlane not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackPlane' unknown data size is not allowed")),
        };
        let mut track_plane_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_plane_type: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackPlaneUid => {
                    let size = size.try_sized(EbmlId::TrackPlaneUid)?;
                    track_plane_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TrackPlaneType => {
                    let size = size.try_sized(EbmlId::TrackPlaneType)?;
                    track_plane_type.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackPlane'", id))?,
            }
            index += 1;
        }

        if track_plane_uid.len() != 1 { Err(anyhow::anyhow!("One element 'TrackPlaneUid' must be in 'TrackPlane'. Found {}", track_plane_uid.len()))? }
        let track_plane_uid = track_plane_uid.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackPlaneUid' doesn't exist in 'TrackPlane'"))?;
        if track_plane_type.len() != 1 { Err(anyhow::anyhow!("One element 'TrackPlaneType' must be in 'TrackPlane'. Found {}", track_plane_type.len()))? }
        let track_plane_type = track_plane_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackPlaneType' doesn't exist in 'TrackPlane'"))?;

        Ok((Self{
            size,

            track_plane_uid,
            track_plane_type,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for TrackPlane {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::TrackPlane { return Err(anyhow::anyhow!("TrackPlane not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackPlane' unknown data size is not allowed")),
        };
        let mut track_plane_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut track_plane_type: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackPlaneUid => {
                    let size = size.try_sized(EbmlId::TrackPlaneUid)?;
                    track_plane_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TrackPlaneType => {
                    let size = size.try_sized(EbmlId::TrackPlaneType)?;
                    track_plane_type.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackPlane'", id))?,
            }
            index += 1;
        }

        if track_plane_uid.len() != 1 { Err(anyhow::anyhow!("One element 'TrackPlaneUid' must be in 'TrackPlane'. Found {}", track_plane_uid.len()))? }
        let track_plane_uid = track_plane_uid.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackPlaneUid' doesn't exist in 'TrackPlane'"))?;
        if track_plane_type.len() != 1 { Err(anyhow::anyhow!("One element 'TrackPlaneType' must be in 'TrackPlane'. Found {}", track_plane_type.len()))? }
        let track_plane_type = track_plane_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TrackPlaneType' doesn't exist in 'TrackPlane'"))?;

        Ok((Self{
            size,

            track_plane_uid,
            track_plane_type,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for TrackJoinBlocks {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::TrackJoinBlocks { return Err(anyhow::anyhow!("TrackJoinBlocks not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackJoinBlocks' unknown data size is not allowed")),
        };
        let mut track_join_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackJoinUid => {
                    let size = size.try_sized(EbmlId::TrackJoinUid)?;
                    track_join_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackJoinBlocks'", id))?,
            }
            index += 1;
        }

        let track_join_uid = Vec::from(track_join_uid);

        Ok((Self{
            size,

            track_join_uid,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for TrackJoinBlocks {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::TrackJoinBlocks { return Err(anyhow::anyhow!("TrackJoinBlocks not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'TrackJoinBlocks' unknown data size is not allowed")),
        };
        let mut track_join_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TrackJoinUid => {
                    let size = size.try_sized(EbmlId::TrackJoinUid)?;
                    track_join_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'TrackJoinBlocks'", id))?,
            }
            index += 1;
        }

        let track_join_uid = Vec::from(track_join_uid);

        Ok((Self{
            size,

            track_join_uid,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ContentEncodings {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ContentEncodings { return Err(anyhow::anyhow!("ContentEncodings not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentEncodings' unknown data size is not allowed")),
        };
        let mut content_encoding: VecDeque<Ebml<ContentEncoding>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ContentEncoding => {
                    let (val, read) = ContentEncoding::read_body(r, size)?;
                    content_encoding.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentEncodings'", id))?,
            }
            index += 1;
        }

        let content_encoding = Vec::from(content_encoding);

        Ok((Self{
            size,

            content_encoding,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ContentEncodings {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ContentEncodings { return Err(anyhow::anyhow!("ContentEncodings not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentEncodings' unknown data size is not allowed")),
        };
        let mut content_encoding: VecDeque<Ebml<ContentEncoding>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ContentEncoding => {
                    let (val, read) = ContentEncoding::read_body(r, size).await?;
                    content_encoding.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentEncodings'", id))?,
            }
            index += 1;
        }

        let content_encoding = Vec::from(content_encoding);

        Ok((Self{
            size,

            content_encoding,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ContentEncoding {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ContentEncoding { return Err(anyhow::anyhow!("ContentEncoding not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentEncoding' unknown data size is not allowed")),
        };
        let mut content_encoding_order: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_encoding_scope: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_encoding_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_compression: VecDeque<Ebml<ContentCompression>> = VecDeque::new();
        let mut content_encryption: VecDeque<Ebml<ContentEncryption>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ContentEncodingOrder => {
                    let size = size.try_sized(EbmlId::ContentEncodingOrder)?;
                    content_encoding_order.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncodingScope => {
                    let size = size.try_sized(EbmlId::ContentEncodingScope)?;
                    content_encoding_scope.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncodingType => {
                    let size = size.try_sized(EbmlId::ContentEncodingType)?;
                    content_encoding_type.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentCompression => {
                    let (val, read) = ContentCompression::read_body(r, size)?;
                    content_compression.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ContentEncryption => {
                    let (val, read) = ContentEncryption::read_body(r, size)?;
                    content_encryption.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentEncoding'", id))?,
            }
            index += 1;
        }

        if content_encoding_order.len() == 0 { content_encoding_order.push_back(Ebml::new(0)); }
        if content_encoding_order.len() != 1 { Err(anyhow::anyhow!("One element 'ContentEncodingOrder' must be in 'ContentEncoding'. Found {}", content_encoding_order.len()))? }
        let content_encoding_order = content_encoding_order.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentEncodingOrder' doesn't exist in 'ContentEncoding'"))?;
        if content_encoding_scope.len() == 0 { content_encoding_scope.push_back(Ebml::new(1)); }
        if content_encoding_scope.len() != 1 { Err(anyhow::anyhow!("One element 'ContentEncodingScope' must be in 'ContentEncoding'. Found {}", content_encoding_scope.len()))? }
        let content_encoding_scope = content_encoding_scope.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentEncodingScope' doesn't exist in 'ContentEncoding'"))?;
        if content_encoding_type.len() == 0 { content_encoding_type.push_back(Ebml::new(0)); }
        if content_encoding_type.len() != 1 { Err(anyhow::anyhow!("One element 'ContentEncodingType' must be in 'ContentEncoding'. Found {}", content_encoding_type.len()))? }
        let content_encoding_type = content_encoding_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentEncodingType' doesn't exist in 'ContentEncoding'"))?;
        if content_compression.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentCompression' in 'ContentEncoding' possible. Found {}", content_compression.len()))? }
        let content_compression = content_compression.pop_front();
        if content_encryption.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentEncryption' in 'ContentEncoding' possible. Found {}", content_encryption.len()))? }
        let content_encryption = content_encryption.pop_front();

        Ok((Self{
            size,

            content_encoding_order,
            content_encoding_scope,
            content_encoding_type,
            content_compression,
            content_encryption,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ContentEncoding {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ContentEncoding { return Err(anyhow::anyhow!("ContentEncoding not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentEncoding' unknown data size is not allowed")),
        };
        let mut content_encoding_order: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_encoding_scope: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_encoding_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_compression: VecDeque<Ebml<ContentCompression>> = VecDeque::new();
        let mut content_encryption: VecDeque<Ebml<ContentEncryption>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ContentEncodingOrder => {
                    let size = size.try_sized(EbmlId::ContentEncodingOrder)?;
                    content_encoding_order.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncodingScope => {
                    let size = size.try_sized(EbmlId::ContentEncodingScope)?;
                    content_encoding_scope.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncodingType => {
                    let size = size.try_sized(EbmlId::ContentEncodingType)?;
                    content_encoding_type.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentCompression => {
                    let (val, read) = ContentCompression::read_body(r, size).await?;
                    content_compression.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ContentEncryption => {
                    let (val, read) = ContentEncryption::read_body(r, size).await?;
                    content_encryption.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentEncoding'", id))?,
            }
            index += 1;
        }

        if content_encoding_order.len() == 0 { content_encoding_order.push_back(Ebml::new(0)); }
        if content_encoding_order.len() != 1 { Err(anyhow::anyhow!("One element 'ContentEncodingOrder' must be in 'ContentEncoding'. Found {}", content_encoding_order.len()))? }
        let content_encoding_order = content_encoding_order.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentEncodingOrder' doesn't exist in 'ContentEncoding'"))?;
        if content_encoding_scope.len() == 0 { content_encoding_scope.push_back(Ebml::new(1)); }
        if content_encoding_scope.len() != 1 { Err(anyhow::anyhow!("One element 'ContentEncodingScope' must be in 'ContentEncoding'. Found {}", content_encoding_scope.len()))? }
        let content_encoding_scope = content_encoding_scope.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentEncodingScope' doesn't exist in 'ContentEncoding'"))?;
        if content_encoding_type.len() == 0 { content_encoding_type.push_back(Ebml::new(0)); }
        if content_encoding_type.len() != 1 { Err(anyhow::anyhow!("One element 'ContentEncodingType' must be in 'ContentEncoding'. Found {}", content_encoding_type.len()))? }
        let content_encoding_type = content_encoding_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentEncodingType' doesn't exist in 'ContentEncoding'"))?;
        if content_compression.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentCompression' in 'ContentEncoding' possible. Found {}", content_compression.len()))? }
        let content_compression = content_compression.pop_front();
        if content_encryption.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentEncryption' in 'ContentEncoding' possible. Found {}", content_encryption.len()))? }
        let content_encryption = content_encryption.pop_front();

        Ok((Self{
            size,

            content_encoding_order,
            content_encoding_scope,
            content_encoding_type,
            content_compression,
            content_encryption,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ContentCompression {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ContentCompression { return Err(anyhow::anyhow!("ContentCompression not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentCompression' unknown data size is not allowed")),
        };
        let mut content_comp_algo: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_comp_settings: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ContentCompAlgo => {
                    let size = size.try_sized(EbmlId::ContentCompAlgo)?;
                    content_comp_algo.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentCompSettings => {
                    let size = size.try_sized(EbmlId::ContentCompSettings)?;
                    content_comp_settings.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentCompression'", id))?,
            }
            index += 1;
        }

        if content_comp_algo.len() == 0 { content_comp_algo.push_back(Ebml::new(0)); }
        if content_comp_algo.len() != 1 { Err(anyhow::anyhow!("One element 'ContentCompAlgo' must be in 'ContentCompression'. Found {}", content_comp_algo.len()))? }
        let content_comp_algo = content_comp_algo.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentCompAlgo' doesn't exist in 'ContentCompression'"))?;
        if content_comp_settings.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentCompSettings' in 'ContentCompression' possible. Found {}", content_comp_settings.len()))? }
        let content_comp_settings = content_comp_settings.pop_front();

        Ok((Self{
            size,

            content_comp_algo,
            content_comp_settings,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ContentCompression {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ContentCompression { return Err(anyhow::anyhow!("ContentCompression not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentCompression' unknown data size is not allowed")),
        };
        let mut content_comp_algo: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_comp_settings: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ContentCompAlgo => {
                    let size = size.try_sized(EbmlId::ContentCompAlgo)?;
                    content_comp_algo.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentCompSettings => {
                    let size = size.try_sized(EbmlId::ContentCompSettings)?;
                    content_comp_settings.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentCompression'", id))?,
            }
            index += 1;
        }

        if content_comp_algo.len() == 0 { content_comp_algo.push_back(Ebml::new(0)); }
        if content_comp_algo.len() != 1 { Err(anyhow::anyhow!("One element 'ContentCompAlgo' must be in 'ContentCompression'. Found {}", content_comp_algo.len()))? }
        let content_comp_algo = content_comp_algo.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentCompAlgo' doesn't exist in 'ContentCompression'"))?;
        if content_comp_settings.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentCompSettings' in 'ContentCompression' possible. Found {}", content_comp_settings.len()))? }
        let content_comp_settings = content_comp_settings.pop_front();

        Ok((Self{
            size,

            content_comp_algo,
            content_comp_settings,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ContentEncryption {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ContentEncryption { return Err(anyhow::anyhow!("ContentEncryption not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentEncryption' unknown data size is not allowed")),
        };
        let mut content_enc_algo: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_enc_key_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut content_enc_aes_settings: VecDeque<Ebml<ContentEncAesSettings>> = VecDeque::new();
        let mut content_signature: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut content_sig_key_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut content_sig_algo: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_sig_hash_algo: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ContentEncAlgo => {
                    let size = size.try_sized(EbmlId::ContentEncAlgo)?;
                    content_enc_algo.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncKeyId => {
                    let size = size.try_sized(EbmlId::ContentEncKeyId)?;
                    content_enc_key_id.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncAesSettings => {
                    let (val, read) = ContentEncAesSettings::read_body(r, size)?;
                    content_enc_aes_settings.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ContentSignature => {
                    let size = size.try_sized(EbmlId::ContentSignature)?;
                    content_signature.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentSigKeyId => {
                    let size = size.try_sized(EbmlId::ContentSigKeyId)?;
                    content_sig_key_id.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentSigAlgo => {
                    let size = size.try_sized(EbmlId::ContentSigAlgo)?;
                    content_sig_algo.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ContentSigHashAlgo => {
                    let size = size.try_sized(EbmlId::ContentSigHashAlgo)?;
                    content_sig_hash_algo.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentEncryption'", id))?,
            }
            index += 1;
        }

        if content_enc_algo.len() == 0 { content_enc_algo.push_back(Ebml::new(0)); }
        if content_enc_algo.len() != 1 { Err(anyhow::anyhow!("One element 'ContentEncAlgo' must be in 'ContentEncryption'. Found {}", content_enc_algo.len()))? }
        let content_enc_algo = content_enc_algo.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentEncAlgo' doesn't exist in 'ContentEncryption'"))?;
        if content_enc_key_id.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentEncKeyId' in 'ContentEncryption' possible. Found {}", content_enc_key_id.len()))? }
        let content_enc_key_id = content_enc_key_id.pop_front();
        if content_enc_aes_settings.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentEncAesSettings' in 'ContentEncryption' possible. Found {}", content_enc_aes_settings.len()))? }
        let content_enc_aes_settings = content_enc_aes_settings.pop_front();
        if content_signature.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentSignature' in 'ContentEncryption' possible. Found {}", content_signature.len()))? }
        let content_signature = content_signature.pop_front();
        if content_sig_key_id.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentSigKeyId' in 'ContentEncryption' possible. Found {}", content_sig_key_id.len()))? }
        let content_sig_key_id = content_sig_key_id.pop_front();
        if content_sig_algo.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentSigAlgo' in 'ContentEncryption' possible. Found {}", content_sig_algo.len()))? }
        let content_sig_algo = content_sig_algo.pop_front();
        if content_sig_hash_algo.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentSigHashAlgo' in 'ContentEncryption' possible. Found {}", content_sig_hash_algo.len()))? }
        let content_sig_hash_algo = content_sig_hash_algo.pop_front();

        Ok((Self{
            size,

            content_enc_algo,
            content_enc_key_id,
            content_enc_aes_settings,
            content_signature,
            content_sig_key_id,
            content_sig_algo,
            content_sig_hash_algo,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ContentEncryption {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ContentEncryption { return Err(anyhow::anyhow!("ContentEncryption not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentEncryption' unknown data size is not allowed")),
        };
        let mut content_enc_algo: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_enc_key_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut content_enc_aes_settings: VecDeque<Ebml<ContentEncAesSettings>> = VecDeque::new();
        let mut content_signature: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut content_sig_key_id: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut content_sig_algo: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut content_sig_hash_algo: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ContentEncAlgo => {
                    let size = size.try_sized(EbmlId::ContentEncAlgo)?;
                    content_enc_algo.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncKeyId => {
                    let size = size.try_sized(EbmlId::ContentEncKeyId)?;
                    content_enc_key_id.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentEncAesSettings => {
                    let (val, read) = ContentEncAesSettings::read_body(r, size).await?;
                    content_enc_aes_settings.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ContentSignature => {
                    let size = size.try_sized(EbmlId::ContentSignature)?;
                    content_signature.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentSigKeyId => {
                    let size = size.try_sized(EbmlId::ContentSigKeyId)?;
                    content_sig_key_id.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentSigAlgo => {
                    let size = size.try_sized(EbmlId::ContentSigAlgo)?;
                    content_sig_algo.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ContentSigHashAlgo => {
                    let size = size.try_sized(EbmlId::ContentSigHashAlgo)?;
                    content_sig_hash_algo.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentEncryption'", id))?,
            }
            index += 1;
        }

        if content_enc_algo.len() == 0 { content_enc_algo.push_back(Ebml::new(0)); }
        if content_enc_algo.len() != 1 { Err(anyhow::anyhow!("One element 'ContentEncAlgo' must be in 'ContentEncryption'. Found {}", content_enc_algo.len()))? }
        let content_enc_algo = content_enc_algo.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ContentEncAlgo' doesn't exist in 'ContentEncryption'"))?;
        if content_enc_key_id.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentEncKeyId' in 'ContentEncryption' possible. Found {}", content_enc_key_id.len()))? }
        let content_enc_key_id = content_enc_key_id.pop_front();
        if content_enc_aes_settings.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentEncAesSettings' in 'ContentEncryption' possible. Found {}", content_enc_aes_settings.len()))? }
        let content_enc_aes_settings = content_enc_aes_settings.pop_front();
        if content_signature.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentSignature' in 'ContentEncryption' possible. Found {}", content_signature.len()))? }
        let content_signature = content_signature.pop_front();
        if content_sig_key_id.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentSigKeyId' in 'ContentEncryption' possible. Found {}", content_sig_key_id.len()))? }
        let content_sig_key_id = content_sig_key_id.pop_front();
        if content_sig_algo.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentSigAlgo' in 'ContentEncryption' possible. Found {}", content_sig_algo.len()))? }
        let content_sig_algo = content_sig_algo.pop_front();
        if content_sig_hash_algo.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ContentSigHashAlgo' in 'ContentEncryption' possible. Found {}", content_sig_hash_algo.len()))? }
        let content_sig_hash_algo = content_sig_hash_algo.pop_front();

        Ok((Self{
            size,

            content_enc_algo,
            content_enc_key_id,
            content_enc_aes_settings,
            content_signature,
            content_sig_key_id,
            content_sig_algo,
            content_sig_hash_algo,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ContentEncAesSettings {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ContentEncAesSettings { return Err(anyhow::anyhow!("ContentEncAesSettings not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentEncAesSettings' unknown data size is not allowed")),
        };
        let mut aes_settings_cipher_mode: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::AesSettingsCipherMode => {
                    let size = size.try_sized(EbmlId::AesSettingsCipherMode)?;
                    aes_settings_cipher_mode.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentEncAesSettings'", id))?,
            }
            index += 1;
        }

        if aes_settings_cipher_mode.len() != 1 { Err(anyhow::anyhow!("One element 'AesSettingsCipherMode' must be in 'ContentEncAesSettings'. Found {}", aes_settings_cipher_mode.len()))? }
        let aes_settings_cipher_mode = aes_settings_cipher_mode.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'AesSettingsCipherMode' doesn't exist in 'ContentEncAesSettings'"))?;

        Ok((Self{
            size,

            aes_settings_cipher_mode,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ContentEncAesSettings {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ContentEncAesSettings { return Err(anyhow::anyhow!("ContentEncAesSettings not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ContentEncAesSettings' unknown data size is not allowed")),
        };
        let mut aes_settings_cipher_mode: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::AesSettingsCipherMode => {
                    let size = size.try_sized(EbmlId::AesSettingsCipherMode)?;
                    aes_settings_cipher_mode.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ContentEncAesSettings'", id))?,
            }
            index += 1;
        }

        if aes_settings_cipher_mode.len() != 1 { Err(anyhow::anyhow!("One element 'AesSettingsCipherMode' must be in 'ContentEncAesSettings'. Found {}", aes_settings_cipher_mode.len()))? }
        let aes_settings_cipher_mode = aes_settings_cipher_mode.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'AesSettingsCipherMode' doesn't exist in 'ContentEncAesSettings'"))?;

        Ok((Self{
            size,

            aes_settings_cipher_mode,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Cues {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Cues { return Err(anyhow::anyhow!("Cues not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Cues' unknown data size is not allowed")),
        };
        let mut cue_point: VecDeque<Ebml<CuePoint>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::CuePoint => {
                    let (val, read) = CuePoint::read_body(r, size)?;
                    cue_point.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Cues'", id))?,
            }
            index += 1;
        }

        let cue_point = Vec::from(cue_point);

        Ok((Self{
            size,

            cue_point,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Cues {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Cues { return Err(anyhow::anyhow!("Cues not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Cues' unknown data size is not allowed")),
        };
        let mut cue_point: VecDeque<Ebml<CuePoint>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::CuePoint => {
                    let (val, read) = CuePoint::read_body(r, size).await?;
                    cue_point.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Cues'", id))?,
            }
            index += 1;
        }

        let cue_point = Vec::from(cue_point);

        Ok((Self{
            size,

            cue_point,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for CuePoint {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::CuePoint { return Err(anyhow::anyhow!("CuePoint not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'CuePoint' unknown data size is not allowed")),
        };
        let mut cue_time: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_track_positions: VecDeque<Ebml<CueTrackPositions>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::CueTime => {
                    let size = size.try_sized(EbmlId::CueTime)?;
                    cue_time.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueTrackPositions => {
                    let (val, read) = CueTrackPositions::read_body(r, size)?;
                    cue_track_positions.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'CuePoint'", id))?,
            }
            index += 1;
        }

        if cue_time.len() != 1 { Err(anyhow::anyhow!("One element 'CueTime' must be in 'CuePoint'. Found {}", cue_time.len()))? }
        let cue_time = cue_time.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueTime' doesn't exist in 'CuePoint'"))?;
        let cue_track_positions = Vec::from(cue_track_positions);

        Ok((Self{
            size,

            cue_time,
            cue_track_positions,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for CuePoint {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::CuePoint { return Err(anyhow::anyhow!("CuePoint not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'CuePoint' unknown data size is not allowed")),
        };
        let mut cue_time: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_track_positions: VecDeque<Ebml<CueTrackPositions>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::CueTime => {
                    let size = size.try_sized(EbmlId::CueTime)?;
                    cue_time.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueTrackPositions => {
                    let (val, read) = CueTrackPositions::read_body(r, size).await?;
                    cue_track_positions.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'CuePoint'", id))?,
            }
            index += 1;
        }

        if cue_time.len() != 1 { Err(anyhow::anyhow!("One element 'CueTime' must be in 'CuePoint'. Found {}", cue_time.len()))? }
        let cue_time = cue_time.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueTime' doesn't exist in 'CuePoint'"))?;
        let cue_track_positions = Vec::from(cue_track_positions);

        Ok((Self{
            size,

            cue_time,
            cue_track_positions,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for CueTrackPositions {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::CueTrackPositions { return Err(anyhow::anyhow!("CueTrackPositions not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'CueTrackPositions' unknown data size is not allowed")),
        };
        let mut cue_track: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_cluster_position: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_relative_position: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_duration: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_block_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_codec_state: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_reference: VecDeque<Ebml<CueReference>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::CueTrack => {
                    let size = size.try_sized(EbmlId::CueTrack)?;
                    cue_track.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueClusterPosition => {
                    let size = size.try_sized(EbmlId::CueClusterPosition)?;
                    cue_cluster_position.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueRelativePosition => {
                    let size = size.try_sized(EbmlId::CueRelativePosition)?;
                    cue_relative_position.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueDuration => {
                    let size = size.try_sized(EbmlId::CueDuration)?;
                    cue_duration.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueBlockNumber => {
                    let size = size.try_sized(EbmlId::CueBlockNumber)?;
                    cue_block_number.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueCodecState => {
                    let size = size.try_sized(EbmlId::CueCodecState)?;
                    cue_codec_state.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueReference => {
                    let (val, read) = CueReference::read_body(r, size)?;
                    cue_reference.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'CueTrackPositions'", id))?,
            }
            index += 1;
        }

        if cue_track.len() != 1 { Err(anyhow::anyhow!("One element 'CueTrack' must be in 'CueTrackPositions'. Found {}", cue_track.len()))? }
        let cue_track = cue_track.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueTrack' doesn't exist in 'CueTrackPositions'"))?;
        if cue_cluster_position.len() != 1 { Err(anyhow::anyhow!("One element 'CueClusterPosition' must be in 'CueTrackPositions'. Found {}", cue_cluster_position.len()))? }
        let cue_cluster_position = cue_cluster_position.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueClusterPosition' doesn't exist in 'CueTrackPositions'"))?;
        if cue_relative_position.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueRelativePosition' in 'CueTrackPositions' possible. Found {}", cue_relative_position.len()))? }
        let cue_relative_position = cue_relative_position.pop_front();
        if cue_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueDuration' in 'CueTrackPositions' possible. Found {}", cue_duration.len()))? }
        let cue_duration = cue_duration.pop_front();
        if cue_block_number.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueBlockNumber' in 'CueTrackPositions' possible. Found {}", cue_block_number.len()))? }
        let cue_block_number = cue_block_number.pop_front();
        if cue_codec_state.len() == 0 { cue_codec_state.push_back(Ebml::new(0)); }
        if cue_codec_state.len() != 1 { Err(anyhow::anyhow!("One element 'CueCodecState' must be in 'CueTrackPositions'. Found {}", cue_codec_state.len()))? }
        let cue_codec_state = cue_codec_state.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueCodecState' doesn't exist in 'CueTrackPositions'"))?;
        let cue_reference = Vec::from(cue_reference);

        Ok((Self{
            size,

            cue_track,
            cue_cluster_position,
            cue_relative_position,
            cue_duration,
            cue_block_number,
            cue_codec_state,
            cue_reference,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for CueTrackPositions {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::CueTrackPositions { return Err(anyhow::anyhow!("CueTrackPositions not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'CueTrackPositions' unknown data size is not allowed")),
        };
        let mut cue_track: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_cluster_position: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_relative_position: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_duration: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_block_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_codec_state: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_reference: VecDeque<Ebml<CueReference>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::CueTrack => {
                    let size = size.try_sized(EbmlId::CueTrack)?;
                    cue_track.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueClusterPosition => {
                    let size = size.try_sized(EbmlId::CueClusterPosition)?;
                    cue_cluster_position.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueRelativePosition => {
                    let size = size.try_sized(EbmlId::CueRelativePosition)?;
                    cue_relative_position.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueDuration => {
                    let size = size.try_sized(EbmlId::CueDuration)?;
                    cue_duration.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueBlockNumber => {
                    let size = size.try_sized(EbmlId::CueBlockNumber)?;
                    cue_block_number.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueCodecState => {
                    let size = size.try_sized(EbmlId::CueCodecState)?;
                    cue_codec_state.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueReference => {
                    let (val, read) = CueReference::read_body(r, size).await?;
                    cue_reference.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'CueTrackPositions'", id))?,
            }
            index += 1;
        }

        if cue_track.len() != 1 { Err(anyhow::anyhow!("One element 'CueTrack' must be in 'CueTrackPositions'. Found {}", cue_track.len()))? }
        let cue_track = cue_track.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueTrack' doesn't exist in 'CueTrackPositions'"))?;
        if cue_cluster_position.len() != 1 { Err(anyhow::anyhow!("One element 'CueClusterPosition' must be in 'CueTrackPositions'. Found {}", cue_cluster_position.len()))? }
        let cue_cluster_position = cue_cluster_position.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueClusterPosition' doesn't exist in 'CueTrackPositions'"))?;
        if cue_relative_position.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueRelativePosition' in 'CueTrackPositions' possible. Found {}", cue_relative_position.len()))? }
        let cue_relative_position = cue_relative_position.pop_front();
        if cue_duration.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueDuration' in 'CueTrackPositions' possible. Found {}", cue_duration.len()))? }
        let cue_duration = cue_duration.pop_front();
        if cue_block_number.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueBlockNumber' in 'CueTrackPositions' possible. Found {}", cue_block_number.len()))? }
        let cue_block_number = cue_block_number.pop_front();
        if cue_codec_state.len() == 0 { cue_codec_state.push_back(Ebml::new(0)); }
        if cue_codec_state.len() != 1 { Err(anyhow::anyhow!("One element 'CueCodecState' must be in 'CueTrackPositions'. Found {}", cue_codec_state.len()))? }
        let cue_codec_state = cue_codec_state.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueCodecState' doesn't exist in 'CueTrackPositions'"))?;
        let cue_reference = Vec::from(cue_reference);

        Ok((Self{
            size,

            cue_track,
            cue_cluster_position,
            cue_relative_position,
            cue_duration,
            cue_block_number,
            cue_codec_state,
            cue_reference,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for CueReference {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::CueReference { return Err(anyhow::anyhow!("CueReference not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'CueReference' unknown data size is not allowed")),
        };
        let mut cue_ref_time: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_ref_cluster: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_ref_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_ref_codec_state: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::CueRefTime => {
                    let size = size.try_sized(EbmlId::CueRefTime)?;
                    cue_ref_time.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueRefCluster => {
                    let size = size.try_sized(EbmlId::CueRefCluster)?;
                    cue_ref_cluster.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueRefNumber => {
                    let size = size.try_sized(EbmlId::CueRefNumber)?;
                    cue_ref_number.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::CueRefCodecState => {
                    let size = size.try_sized(EbmlId::CueRefCodecState)?;
                    cue_ref_codec_state.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'CueReference'", id))?,
            }
            index += 1;
        }

        if cue_ref_time.len() != 1 { Err(anyhow::anyhow!("One element 'CueRefTime' must be in 'CueReference'. Found {}", cue_ref_time.len()))? }
        let cue_ref_time = cue_ref_time.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueRefTime' doesn't exist in 'CueReference'"))?;
        if cue_ref_cluster.len() != 1 { Err(anyhow::anyhow!("One element 'CueRefCluster' must be in 'CueReference'. Found {}", cue_ref_cluster.len()))? }
        let cue_ref_cluster = cue_ref_cluster.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueRefCluster' doesn't exist in 'CueReference'"))?;
        if cue_ref_number.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueRefNumber' in 'CueReference' possible. Found {}", cue_ref_number.len()))? }
        let cue_ref_number = cue_ref_number.pop_front();
        if cue_ref_codec_state.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueRefCodecState' in 'CueReference' possible. Found {}", cue_ref_codec_state.len()))? }
        let cue_ref_codec_state = cue_ref_codec_state.pop_front();

        Ok((Self{
            size,

            cue_ref_time,
            cue_ref_cluster,
            cue_ref_number,
            cue_ref_codec_state,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for CueReference {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::CueReference { return Err(anyhow::anyhow!("CueReference not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'CueReference' unknown data size is not allowed")),
        };
        let mut cue_ref_time: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_ref_cluster: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_ref_number: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut cue_ref_codec_state: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::CueRefTime => {
                    let size = size.try_sized(EbmlId::CueRefTime)?;
                    cue_ref_time.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueRefCluster => {
                    let size = size.try_sized(EbmlId::CueRefCluster)?;
                    cue_ref_cluster.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueRefNumber => {
                    let size = size.try_sized(EbmlId::CueRefNumber)?;
                    cue_ref_number.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::CueRefCodecState => {
                    let size = size.try_sized(EbmlId::CueRefCodecState)?;
                    cue_ref_codec_state.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'CueReference'", id))?,
            }
            index += 1;
        }

        if cue_ref_time.len() != 1 { Err(anyhow::anyhow!("One element 'CueRefTime' must be in 'CueReference'. Found {}", cue_ref_time.len()))? }
        let cue_ref_time = cue_ref_time.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueRefTime' doesn't exist in 'CueReference'"))?;
        if cue_ref_cluster.len() != 1 { Err(anyhow::anyhow!("One element 'CueRefCluster' must be in 'CueReference'. Found {}", cue_ref_cluster.len()))? }
        let cue_ref_cluster = cue_ref_cluster.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'CueRefCluster' doesn't exist in 'CueReference'"))?;
        if cue_ref_number.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueRefNumber' in 'CueReference' possible. Found {}", cue_ref_number.len()))? }
        let cue_ref_number = cue_ref_number.pop_front();
        if cue_ref_codec_state.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'CueRefCodecState' in 'CueReference' possible. Found {}", cue_ref_codec_state.len()))? }
        let cue_ref_codec_state = cue_ref_codec_state.pop_front();

        Ok((Self{
            size,

            cue_ref_time,
            cue_ref_cluster,
            cue_ref_number,
            cue_ref_codec_state,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Attachments {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Attachments { return Err(anyhow::anyhow!("Attachments not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Attachments' unknown data size is not allowed")),
        };
        let mut attached_file: VecDeque<Ebml<AttachedFile>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::AttachedFile => {
                    let (val, read) = AttachedFile::read_body(r, size)?;
                    attached_file.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Attachments'", id))?,
            }
            index += 1;
        }

        let attached_file = Vec::from(attached_file);

        Ok((Self{
            size,

            attached_file,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Attachments {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Attachments { return Err(anyhow::anyhow!("Attachments not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Attachments' unknown data size is not allowed")),
        };
        let mut attached_file: VecDeque<Ebml<AttachedFile>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::AttachedFile => {
                    let (val, read) = AttachedFile::read_body(r, size).await?;
                    attached_file.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Attachments'", id))?,
            }
            index += 1;
        }

        let attached_file = Vec::from(attached_file);

        Ok((Self{
            size,

            attached_file,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for AttachedFile {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::AttachedFile { return Err(anyhow::anyhow!("AttachedFile not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'AttachedFile' unknown data size is not allowed")),
        };
        let mut file_description: VecDeque<Ebml<String>> = VecDeque::new();
        let mut file_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut file_media_type: VecDeque<Ebml<String>> = VecDeque::new();
        let mut file_data: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut file_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut file_referral: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut file_used_start_time: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut file_used_end_time: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::FileDescription => {
                    let size = size.try_sized(EbmlId::FileDescription)?;
                    file_description.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FileName => {
                    let size = size.try_sized(EbmlId::FileName)?;
                    file_name.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FileMediaType => {
                    let size = size.try_sized(EbmlId::FileMediaType)?;
                    file_media_type.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FileData => {
                    let size = size.try_sized(EbmlId::FileData)?;
                    file_data.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FileUid => {
                    let size = size.try_sized(EbmlId::FileUid)?;
                    file_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FileReferral => {
                    let size = size.try_sized(EbmlId::FileReferral)?;
                    file_referral.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FileUsedStartTime => {
                    let size = size.try_sized(EbmlId::FileUsedStartTime)?;
                    file_used_start_time.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::FileUsedEndTime => {
                    let size = size.try_sized(EbmlId::FileUsedEndTime)?;
                    file_used_end_time.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'AttachedFile'", id))?,
            }
            index += 1;
        }

        if file_description.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FileDescription' in 'AttachedFile' possible. Found {}", file_description.len()))? }
        let file_description = file_description.pop_front();
        if file_name.len() != 1 { Err(anyhow::anyhow!("One element 'FileName' must be in 'AttachedFile'. Found {}", file_name.len()))? }
        let file_name = file_name.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FileName' doesn't exist in 'AttachedFile'"))?;
        if file_media_type.len() != 1 { Err(anyhow::anyhow!("One element 'FileMediaType' must be in 'AttachedFile'. Found {}", file_media_type.len()))? }
        let file_media_type = file_media_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FileMediaType' doesn't exist in 'AttachedFile'"))?;
        if file_data.len() != 1 { Err(anyhow::anyhow!("One element 'FileData' must be in 'AttachedFile'. Found {}", file_data.len()))? }
        let file_data = file_data.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FileData' doesn't exist in 'AttachedFile'"))?;
        if file_uid.len() != 1 { Err(anyhow::anyhow!("One element 'FileUid' must be in 'AttachedFile'. Found {}", file_uid.len()))? }
        let file_uid = file_uid.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FileUid' doesn't exist in 'AttachedFile'"))?;
        if file_referral.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FileReferral' in 'AttachedFile' possible. Found {}", file_referral.len()))? }
        let file_referral = file_referral.pop_front();
        if file_used_start_time.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FileUsedStartTime' in 'AttachedFile' possible. Found {}", file_used_start_time.len()))? }
        let file_used_start_time = file_used_start_time.pop_front();
        if file_used_end_time.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FileUsedEndTime' in 'AttachedFile' possible. Found {}", file_used_end_time.len()))? }
        let file_used_end_time = file_used_end_time.pop_front();

        Ok((Self{
            size,

            file_description,
            file_name,
            file_media_type,
            file_data,
            file_uid,
            file_referral,
            file_used_start_time,
            file_used_end_time,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for AttachedFile {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::AttachedFile { return Err(anyhow::anyhow!("AttachedFile not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'AttachedFile' unknown data size is not allowed")),
        };
        let mut file_description: VecDeque<Ebml<String>> = VecDeque::new();
        let mut file_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut file_media_type: VecDeque<Ebml<String>> = VecDeque::new();
        let mut file_data: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut file_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut file_referral: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut file_used_start_time: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut file_used_end_time: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::FileDescription => {
                    let size = size.try_sized(EbmlId::FileDescription)?;
                    file_description.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FileName => {
                    let size = size.try_sized(EbmlId::FileName)?;
                    file_name.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FileMediaType => {
                    let size = size.try_sized(EbmlId::FileMediaType)?;
                    file_media_type.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FileData => {
                    let size = size.try_sized(EbmlId::FileData)?;
                    file_data.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FileUid => {
                    let size = size.try_sized(EbmlId::FileUid)?;
                    file_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FileReferral => {
                    let size = size.try_sized(EbmlId::FileReferral)?;
                    file_referral.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FileUsedStartTime => {
                    let size = size.try_sized(EbmlId::FileUsedStartTime)?;
                    file_used_start_time.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::FileUsedEndTime => {
                    let size = size.try_sized(EbmlId::FileUsedEndTime)?;
                    file_used_end_time.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'AttachedFile'", id))?,
            }
            index += 1;
        }

        if file_description.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FileDescription' in 'AttachedFile' possible. Found {}", file_description.len()))? }
        let file_description = file_description.pop_front();
        if file_name.len() != 1 { Err(anyhow::anyhow!("One element 'FileName' must be in 'AttachedFile'. Found {}", file_name.len()))? }
        let file_name = file_name.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FileName' doesn't exist in 'AttachedFile'"))?;
        if file_media_type.len() != 1 { Err(anyhow::anyhow!("One element 'FileMediaType' must be in 'AttachedFile'. Found {}", file_media_type.len()))? }
        let file_media_type = file_media_type.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FileMediaType' doesn't exist in 'AttachedFile'"))?;
        if file_data.len() != 1 { Err(anyhow::anyhow!("One element 'FileData' must be in 'AttachedFile'. Found {}", file_data.len()))? }
        let file_data = file_data.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FileData' doesn't exist in 'AttachedFile'"))?;
        if file_uid.len() != 1 { Err(anyhow::anyhow!("One element 'FileUid' must be in 'AttachedFile'. Found {}", file_uid.len()))? }
        let file_uid = file_uid.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'FileUid' doesn't exist in 'AttachedFile'"))?;
        if file_referral.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FileReferral' in 'AttachedFile' possible. Found {}", file_referral.len()))? }
        let file_referral = file_referral.pop_front();
        if file_used_start_time.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FileUsedStartTime' in 'AttachedFile' possible. Found {}", file_used_start_time.len()))? }
        let file_used_start_time = file_used_start_time.pop_front();
        if file_used_end_time.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'FileUsedEndTime' in 'AttachedFile' possible. Found {}", file_used_end_time.len()))? }
        let file_used_end_time = file_used_end_time.pop_front();

        Ok((Self{
            size,

            file_description,
            file_name,
            file_media_type,
            file_data,
            file_uid,
            file_referral,
            file_used_start_time,
            file_used_end_time,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Chapters {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Chapters { return Err(anyhow::anyhow!("Chapters not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Chapters' unknown data size is not allowed")),
        };
        let mut edition_entry: VecDeque<Ebml<EditionEntry>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::EditionEntry => {
                    let (val, read) = EditionEntry::read_body(r, size)?;
                    edition_entry.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Chapters'", id))?,
            }
            index += 1;
        }

        let edition_entry = Vec::from(edition_entry);

        Ok((Self{
            size,

            edition_entry,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Chapters {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Chapters { return Err(anyhow::anyhow!("Chapters not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Chapters' unknown data size is not allowed")),
        };
        let mut edition_entry: VecDeque<Ebml<EditionEntry>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::EditionEntry => {
                    let (val, read) = EditionEntry::read_body(r, size).await?;
                    edition_entry.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Chapters'", id))?,
            }
            index += 1;
        }

        let edition_entry = Vec::from(edition_entry);

        Ok((Self{
            size,

            edition_entry,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for EditionEntry {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::EditionEntry { return Err(anyhow::anyhow!("EditionEntry not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'EditionEntry' unknown data size is not allowed")),
        };
        let mut edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut edition_flag_hidden: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut edition_flag_default: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut edition_flag_ordered: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut edition_display: VecDeque<Ebml<EditionDisplay>> = VecDeque::new();
        let mut chapter_atom: VecDeque<Ebml<ChapterAtom>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::EditionUid => {
                    let size = size.try_sized(EbmlId::EditionUid)?;
                    edition_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::EditionFlagHidden => {
                    let size = size.try_sized(EbmlId::EditionFlagHidden)?;
                    edition_flag_hidden.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::EditionFlagDefault => {
                    let size = size.try_sized(EbmlId::EditionFlagDefault)?;
                    edition_flag_default.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::EditionFlagOrdered => {
                    let size = size.try_sized(EbmlId::EditionFlagOrdered)?;
                    edition_flag_ordered.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::EditionDisplay => {
                    let (val, read) = EditionDisplay::read_body(r, size)?;
                    edition_display.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ChapterAtom => {
                    let (val, read) = ChapterAtom::read_body(r, size)?;
                    chapter_atom.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'EditionEntry'", id))?,
            }
            index += 1;
        }

        if edition_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'EditionUid' in 'EditionEntry' possible. Found {}", edition_uid.len()))? }
        let edition_uid = edition_uid.pop_front();
        if edition_flag_hidden.len() == 0 { edition_flag_hidden.push_back(Ebml::new(0)); }
        if edition_flag_hidden.len() != 1 { Err(anyhow::anyhow!("One element 'EditionFlagHidden' must be in 'EditionEntry'. Found {}", edition_flag_hidden.len()))? }
        let edition_flag_hidden = edition_flag_hidden.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EditionFlagHidden' doesn't exist in 'EditionEntry'"))?;
        if edition_flag_default.len() == 0 { edition_flag_default.push_back(Ebml::new(0)); }
        if edition_flag_default.len() != 1 { Err(anyhow::anyhow!("One element 'EditionFlagDefault' must be in 'EditionEntry'. Found {}", edition_flag_default.len()))? }
        let edition_flag_default = edition_flag_default.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EditionFlagDefault' doesn't exist in 'EditionEntry'"))?;
        if edition_flag_ordered.len() == 0 { edition_flag_ordered.push_back(Ebml::new(0)); }
        if edition_flag_ordered.len() != 1 { Err(anyhow::anyhow!("One element 'EditionFlagOrdered' must be in 'EditionEntry'. Found {}", edition_flag_ordered.len()))? }
        let edition_flag_ordered = edition_flag_ordered.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EditionFlagOrdered' doesn't exist in 'EditionEntry'"))?;
        let edition_display = Vec::from(edition_display);
        let chapter_atom = Vec::from(chapter_atom);

        Ok((Self{
            size,

            edition_uid,
            edition_flag_hidden,
            edition_flag_default,
            edition_flag_ordered,
            edition_display,
            chapter_atom,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for EditionEntry {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::EditionEntry { return Err(anyhow::anyhow!("EditionEntry not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'EditionEntry' unknown data size is not allowed")),
        };
        let mut edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut edition_flag_hidden: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut edition_flag_default: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut edition_flag_ordered: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut edition_display: VecDeque<Ebml<EditionDisplay>> = VecDeque::new();
        let mut chapter_atom: VecDeque<Ebml<ChapterAtom>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::EditionUid => {
                    let size = size.try_sized(EbmlId::EditionUid)?;
                    edition_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::EditionFlagHidden => {
                    let size = size.try_sized(EbmlId::EditionFlagHidden)?;
                    edition_flag_hidden.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::EditionFlagDefault => {
                    let size = size.try_sized(EbmlId::EditionFlagDefault)?;
                    edition_flag_default.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::EditionFlagOrdered => {
                    let size = size.try_sized(EbmlId::EditionFlagOrdered)?;
                    edition_flag_ordered.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::EditionDisplay => {
                    let (val, read) = EditionDisplay::read_body(r, size).await?;
                    edition_display.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ChapterAtom => {
                    let (val, read) = ChapterAtom::read_body(r, size).await?;
                    chapter_atom.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'EditionEntry'", id))?,
            }
            index += 1;
        }

        if edition_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'EditionUid' in 'EditionEntry' possible. Found {}", edition_uid.len()))? }
        let edition_uid = edition_uid.pop_front();
        if edition_flag_hidden.len() == 0 { edition_flag_hidden.push_back(Ebml::new(0)); }
        if edition_flag_hidden.len() != 1 { Err(anyhow::anyhow!("One element 'EditionFlagHidden' must be in 'EditionEntry'. Found {}", edition_flag_hidden.len()))? }
        let edition_flag_hidden = edition_flag_hidden.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EditionFlagHidden' doesn't exist in 'EditionEntry'"))?;
        if edition_flag_default.len() == 0 { edition_flag_default.push_back(Ebml::new(0)); }
        if edition_flag_default.len() != 1 { Err(anyhow::anyhow!("One element 'EditionFlagDefault' must be in 'EditionEntry'. Found {}", edition_flag_default.len()))? }
        let edition_flag_default = edition_flag_default.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EditionFlagDefault' doesn't exist in 'EditionEntry'"))?;
        if edition_flag_ordered.len() == 0 { edition_flag_ordered.push_back(Ebml::new(0)); }
        if edition_flag_ordered.len() != 1 { Err(anyhow::anyhow!("One element 'EditionFlagOrdered' must be in 'EditionEntry'. Found {}", edition_flag_ordered.len()))? }
        let edition_flag_ordered = edition_flag_ordered.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EditionFlagOrdered' doesn't exist in 'EditionEntry'"))?;
        let edition_display = Vec::from(edition_display);
        let chapter_atom = Vec::from(chapter_atom);

        Ok((Self{
            size,

            edition_uid,
            edition_flag_hidden,
            edition_flag_default,
            edition_flag_ordered,
            edition_display,
            chapter_atom,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for EditionDisplay {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::EditionDisplay { return Err(anyhow::anyhow!("EditionDisplay not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'EditionDisplay' unknown data size is not allowed")),
        };
        let mut edition_string: VecDeque<Ebml<String>> = VecDeque::new();
        let mut edition_language_ietf: VecDeque<Ebml<String>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::EditionString => {
                    let size = size.try_sized(EbmlId::EditionString)?;
                    edition_string.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::EditionLanguageIetf => {
                    let size = size.try_sized(EbmlId::EditionLanguageIetf)?;
                    edition_language_ietf.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'EditionDisplay'", id))?,
            }
            index += 1;
        }

        if edition_string.len() != 1 { Err(anyhow::anyhow!("One element 'EditionString' must be in 'EditionDisplay'. Found {}", edition_string.len()))? }
        let edition_string = edition_string.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EditionString' doesn't exist in 'EditionDisplay'"))?;
        let edition_language_ietf = Vec::from(edition_language_ietf);

        Ok((Self{
            size,

            edition_string,
            edition_language_ietf,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for EditionDisplay {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::EditionDisplay { return Err(anyhow::anyhow!("EditionDisplay not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'EditionDisplay' unknown data size is not allowed")),
        };
        let mut edition_string: VecDeque<Ebml<String>> = VecDeque::new();
        let mut edition_language_ietf: VecDeque<Ebml<String>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::EditionString => {
                    let size = size.try_sized(EbmlId::EditionString)?;
                    edition_string.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::EditionLanguageIetf => {
                    let size = size.try_sized(EbmlId::EditionLanguageIetf)?;
                    edition_language_ietf.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'EditionDisplay'", id))?,
            }
            index += 1;
        }

        if edition_string.len() != 1 { Err(anyhow::anyhow!("One element 'EditionString' must be in 'EditionDisplay'. Found {}", edition_string.len()))? }
        let edition_string = edition_string.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'EditionString' doesn't exist in 'EditionDisplay'"))?;
        let edition_language_ietf = Vec::from(edition_language_ietf);

        Ok((Self{
            size,

            edition_string,
            edition_language_ietf,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ChapterAtom {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ChapterAtom { return Err(anyhow::anyhow!("ChapterAtom not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapterAtom' unknown data size is not allowed")),
        };
        let mut chapter_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_string_uid: VecDeque<Ebml<String>> = VecDeque::new();
        let mut chapter_time_start: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_time_end: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_flag_hidden: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_flag_enabled: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_segment_uuid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut chapter_skip_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_segment_edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_physical_equiv: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_track: VecDeque<Ebml<ChapterTrack>> = VecDeque::new();
        let mut chapter_display: VecDeque<Ebml<ChapterDisplay>> = VecDeque::new();
        let mut chap_process: VecDeque<Ebml<ChapProcess>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapterUid => {
                    let size = size.try_sized(EbmlId::ChapterUid)?;
                    chapter_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterStringUid => {
                    let size = size.try_sized(EbmlId::ChapterStringUid)?;
                    chapter_string_uid.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTimeStart => {
                    let size = size.try_sized(EbmlId::ChapterTimeStart)?;
                    chapter_time_start.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTimeEnd => {
                    let size = size.try_sized(EbmlId::ChapterTimeEnd)?;
                    chapter_time_end.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterFlagHidden => {
                    let size = size.try_sized(EbmlId::ChapterFlagHidden)?;
                    chapter_flag_hidden.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterFlagEnabled => {
                    let size = size.try_sized(EbmlId::ChapterFlagEnabled)?;
                    chapter_flag_enabled.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterSegmentUuid => {
                    let size = size.try_sized(EbmlId::ChapterSegmentUuid)?;
                    chapter_segment_uuid.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterSkipType => {
                    let size = size.try_sized(EbmlId::ChapterSkipType)?;
                    chapter_skip_type.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterSegmentEditionUid => {
                    let size = size.try_sized(EbmlId::ChapterSegmentEditionUid)?;
                    chapter_segment_edition_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterPhysicalEquiv => {
                    let size = size.try_sized(EbmlId::ChapterPhysicalEquiv)?;
                    chapter_physical_equiv.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTrack => {
                    let (val, read) = ChapterTrack::read_body(r, size)?;
                    chapter_track.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ChapterDisplay => {
                    let (val, read) = ChapterDisplay::read_body(r, size)?;
                    chapter_display.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ChapProcess => {
                    let (val, read) = ChapProcess::read_body(r, size)?;
                    chap_process.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapterAtom'", id))?,
            }
            index += 1;
        }

        if chapter_uid.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterUid' must be in 'ChapterAtom'. Found {}", chapter_uid.len()))? }
        let chapter_uid = chapter_uid.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterUid' doesn't exist in 'ChapterAtom'"))?;
        if chapter_string_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterStringUid' in 'ChapterAtom' possible. Found {}", chapter_string_uid.len()))? }
        let chapter_string_uid = chapter_string_uid.pop_front();
        if chapter_time_start.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterTimeStart' must be in 'ChapterAtom'. Found {}", chapter_time_start.len()))? }
        let chapter_time_start = chapter_time_start.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterTimeStart' doesn't exist in 'ChapterAtom'"))?;
        if chapter_time_end.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterTimeEnd' in 'ChapterAtom' possible. Found {}", chapter_time_end.len()))? }
        let chapter_time_end = chapter_time_end.pop_front();
        if chapter_flag_hidden.len() == 0 { chapter_flag_hidden.push_back(Ebml::new(0)); }
        if chapter_flag_hidden.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterFlagHidden' must be in 'ChapterAtom'. Found {}", chapter_flag_hidden.len()))? }
        let chapter_flag_hidden = chapter_flag_hidden.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterFlagHidden' doesn't exist in 'ChapterAtom'"))?;
        if chapter_flag_enabled.len() == 0 { chapter_flag_enabled.push_back(Ebml::new(1)); }
        if chapter_flag_enabled.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterFlagEnabled' must be in 'ChapterAtom'. Found {}", chapter_flag_enabled.len()))? }
        let chapter_flag_enabled = chapter_flag_enabled.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterFlagEnabled' doesn't exist in 'ChapterAtom'"))?;
        if chapter_segment_uuid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterSegmentUuid' in 'ChapterAtom' possible. Found {}", chapter_segment_uuid.len()))? }
        let chapter_segment_uuid = chapter_segment_uuid.pop_front();
        if chapter_skip_type.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterSkipType' in 'ChapterAtom' possible. Found {}", chapter_skip_type.len()))? }
        let chapter_skip_type = chapter_skip_type.pop_front();
        if chapter_segment_edition_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterSegmentEditionUid' in 'ChapterAtom' possible. Found {}", chapter_segment_edition_uid.len()))? }
        let chapter_segment_edition_uid = chapter_segment_edition_uid.pop_front();
        if chapter_physical_equiv.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterPhysicalEquiv' in 'ChapterAtom' possible. Found {}", chapter_physical_equiv.len()))? }
        let chapter_physical_equiv = chapter_physical_equiv.pop_front();
        if chapter_track.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterTrack' in 'ChapterAtom' possible. Found {}", chapter_track.len()))? }
        let chapter_track = chapter_track.pop_front();
        let chapter_display = Vec::from(chapter_display);
        let chap_process = Vec::from(chap_process);

        Ok((Self{
            size,

            chapter_uid,
            chapter_string_uid,
            chapter_time_start,
            chapter_time_end,
            chapter_flag_hidden,
            chapter_flag_enabled,
            chapter_segment_uuid,
            chapter_skip_type,
            chapter_segment_edition_uid,
            chapter_physical_equiv,
            chapter_track,
            chapter_display,
            chap_process,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ChapterAtom {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ChapterAtom { return Err(anyhow::anyhow!("ChapterAtom not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapterAtom' unknown data size is not allowed")),
        };
        let mut chapter_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_string_uid: VecDeque<Ebml<String>> = VecDeque::new();
        let mut chapter_time_start: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_time_end: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_flag_hidden: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_flag_enabled: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_segment_uuid: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut chapter_skip_type: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_segment_edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_physical_equiv: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chapter_track: VecDeque<Ebml<ChapterTrack>> = VecDeque::new();
        let mut chapter_display: VecDeque<Ebml<ChapterDisplay>> = VecDeque::new();
        let mut chap_process: VecDeque<Ebml<ChapProcess>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapterUid => {
                    let size = size.try_sized(EbmlId::ChapterUid)?;
                    chapter_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterStringUid => {
                    let size = size.try_sized(EbmlId::ChapterStringUid)?;
                    chapter_string_uid.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTimeStart => {
                    let size = size.try_sized(EbmlId::ChapterTimeStart)?;
                    chapter_time_start.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTimeEnd => {
                    let size = size.try_sized(EbmlId::ChapterTimeEnd)?;
                    chapter_time_end.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterFlagHidden => {
                    let size = size.try_sized(EbmlId::ChapterFlagHidden)?;
                    chapter_flag_hidden.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterFlagEnabled => {
                    let size = size.try_sized(EbmlId::ChapterFlagEnabled)?;
                    chapter_flag_enabled.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterSegmentUuid => {
                    let size = size.try_sized(EbmlId::ChapterSegmentUuid)?;
                    chapter_segment_uuid.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterSkipType => {
                    let size = size.try_sized(EbmlId::ChapterSkipType)?;
                    chapter_skip_type.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterSegmentEditionUid => {
                    let size = size.try_sized(EbmlId::ChapterSegmentEditionUid)?;
                    chapter_segment_edition_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterPhysicalEquiv => {
                    let size = size.try_sized(EbmlId::ChapterPhysicalEquiv)?;
                    chapter_physical_equiv.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapterTrack => {
                    let (val, read) = ChapterTrack::read_body(r, size).await?;
                    chapter_track.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ChapterDisplay => {
                    let (val, read) = ChapterDisplay::read_body(r, size).await?;
                    chapter_display.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::ChapProcess => {
                    let (val, read) = ChapProcess::read_body(r, size).await?;
                    chap_process.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapterAtom'", id))?,
            }
            index += 1;
        }

        if chapter_uid.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterUid' must be in 'ChapterAtom'. Found {}", chapter_uid.len()))? }
        let chapter_uid = chapter_uid.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterUid' doesn't exist in 'ChapterAtom'"))?;
        if chapter_string_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterStringUid' in 'ChapterAtom' possible. Found {}", chapter_string_uid.len()))? }
        let chapter_string_uid = chapter_string_uid.pop_front();
        if chapter_time_start.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterTimeStart' must be in 'ChapterAtom'. Found {}", chapter_time_start.len()))? }
        let chapter_time_start = chapter_time_start.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterTimeStart' doesn't exist in 'ChapterAtom'"))?;
        if chapter_time_end.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterTimeEnd' in 'ChapterAtom' possible. Found {}", chapter_time_end.len()))? }
        let chapter_time_end = chapter_time_end.pop_front();
        if chapter_flag_hidden.len() == 0 { chapter_flag_hidden.push_back(Ebml::new(0)); }
        if chapter_flag_hidden.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterFlagHidden' must be in 'ChapterAtom'. Found {}", chapter_flag_hidden.len()))? }
        let chapter_flag_hidden = chapter_flag_hidden.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterFlagHidden' doesn't exist in 'ChapterAtom'"))?;
        if chapter_flag_enabled.len() == 0 { chapter_flag_enabled.push_back(Ebml::new(1)); }
        if chapter_flag_enabled.len() != 1 { Err(anyhow::anyhow!("One element 'ChapterFlagEnabled' must be in 'ChapterAtom'. Found {}", chapter_flag_enabled.len()))? }
        let chapter_flag_enabled = chapter_flag_enabled.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapterFlagEnabled' doesn't exist in 'ChapterAtom'"))?;
        if chapter_segment_uuid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterSegmentUuid' in 'ChapterAtom' possible. Found {}", chapter_segment_uuid.len()))? }
        let chapter_segment_uuid = chapter_segment_uuid.pop_front();
        if chapter_skip_type.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterSkipType' in 'ChapterAtom' possible. Found {}", chapter_skip_type.len()))? }
        let chapter_skip_type = chapter_skip_type.pop_front();
        if chapter_segment_edition_uid.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterSegmentEditionUid' in 'ChapterAtom' possible. Found {}", chapter_segment_edition_uid.len()))? }
        let chapter_segment_edition_uid = chapter_segment_edition_uid.pop_front();
        if chapter_physical_equiv.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterPhysicalEquiv' in 'ChapterAtom' possible. Found {}", chapter_physical_equiv.len()))? }
        let chapter_physical_equiv = chapter_physical_equiv.pop_front();
        if chapter_track.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapterTrack' in 'ChapterAtom' possible. Found {}", chapter_track.len()))? }
        let chapter_track = chapter_track.pop_front();
        let chapter_display = Vec::from(chapter_display);
        let chap_process = Vec::from(chap_process);

        Ok((Self{
            size,

            chapter_uid,
            chapter_string_uid,
            chapter_time_start,
            chapter_time_end,
            chapter_flag_hidden,
            chapter_flag_enabled,
            chapter_segment_uuid,
            chapter_skip_type,
            chapter_segment_edition_uid,
            chapter_physical_equiv,
            chapter_track,
            chapter_display,
            chap_process,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ChapterTrack {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ChapterTrack { return Err(anyhow::anyhow!("ChapterTrack not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapterTrack' unknown data size is not allowed")),
        };
        let mut chapter_track_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapterTrackUid => {
                    let size = size.try_sized(EbmlId::ChapterTrackUid)?;
                    chapter_track_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapterTrack'", id))?,
            }
            index += 1;
        }

        let chapter_track_uid = Vec::from(chapter_track_uid);

        Ok((Self{
            size,

            chapter_track_uid,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ChapterTrack {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ChapterTrack { return Err(anyhow::anyhow!("ChapterTrack not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapterTrack' unknown data size is not allowed")),
        };
        let mut chapter_track_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapterTrackUid => {
                    let size = size.try_sized(EbmlId::ChapterTrackUid)?;
                    chapter_track_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapterTrack'", id))?,
            }
            index += 1;
        }

        let chapter_track_uid = Vec::from(chapter_track_uid);

        Ok((Self{
            size,

            chapter_track_uid,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ChapterDisplay {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ChapterDisplay { return Err(anyhow::anyhow!("ChapterDisplay not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapterDisplay' unknown data size is not allowed")),
        };
        let mut chap_string: VecDeque<Ebml<String>> = VecDeque::new();
        let mut chap_language: VecDeque<Ebml<String>> = VecDeque::new();
        let mut chap_language_bcp_47: VecDeque<Ebml<String>> = VecDeque::new();
        let mut chap_country: VecDeque<Ebml<String>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapString => {
                    let size = size.try_sized(EbmlId::ChapString)?;
                    chap_string.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapLanguage => {
                    let size = size.try_sized(EbmlId::ChapLanguage)?;
                    chap_language.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapLanguageBcp47 => {
                    let size = size.try_sized(EbmlId::ChapLanguageBcp47)?;
                    chap_language_bcp_47.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapCountry => {
                    let size = size.try_sized(EbmlId::ChapCountry)?;
                    chap_country.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapterDisplay'", id))?,
            }
            index += 1;
        }

        if chap_string.len() != 1 { Err(anyhow::anyhow!("One element 'ChapString' must be in 'ChapterDisplay'. Found {}", chap_string.len()))? }
        let chap_string = chap_string.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapString' doesn't exist in 'ChapterDisplay'"))?;
        let chap_language = Vec::from(chap_language);
        let chap_language_bcp_47 = Vec::from(chap_language_bcp_47);
        let chap_country = Vec::from(chap_country);

        Ok((Self{
            size,

            chap_string,
            chap_language,
            chap_language_bcp_47,
            chap_country,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ChapterDisplay {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ChapterDisplay { return Err(anyhow::anyhow!("ChapterDisplay not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapterDisplay' unknown data size is not allowed")),
        };
        let mut chap_string: VecDeque<Ebml<String>> = VecDeque::new();
        let mut chap_language: VecDeque<Ebml<String>> = VecDeque::new();
        let mut chap_language_bcp_47: VecDeque<Ebml<String>> = VecDeque::new();
        let mut chap_country: VecDeque<Ebml<String>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapString => {
                    let size = size.try_sized(EbmlId::ChapString)?;
                    chap_string.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapLanguage => {
                    let size = size.try_sized(EbmlId::ChapLanguage)?;
                    chap_language.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapLanguageBcp47 => {
                    let size = size.try_sized(EbmlId::ChapLanguageBcp47)?;
                    chap_language_bcp_47.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapCountry => {
                    let size = size.try_sized(EbmlId::ChapCountry)?;
                    chap_country.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapterDisplay'", id))?,
            }
            index += 1;
        }

        if chap_string.len() != 1 { Err(anyhow::anyhow!("One element 'ChapString' must be in 'ChapterDisplay'. Found {}", chap_string.len()))? }
        let chap_string = chap_string.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapString' doesn't exist in 'ChapterDisplay'"))?;
        let chap_language = Vec::from(chap_language);
        let chap_language_bcp_47 = Vec::from(chap_language_bcp_47);
        let chap_country = Vec::from(chap_country);

        Ok((Self{
            size,

            chap_string,
            chap_language,
            chap_language_bcp_47,
            chap_country,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ChapProcess {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ChapProcess { return Err(anyhow::anyhow!("ChapProcess not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapProcess' unknown data size is not allowed")),
        };
        let mut chap_process_codec_id: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chap_process_private: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut chap_process_command: VecDeque<Ebml<ChapProcessCommand>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapProcessCodecId => {
                    let size = size.try_sized(EbmlId::ChapProcessCodecId)?;
                    chap_process_codec_id.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapProcessPrivate => {
                    let size = size.try_sized(EbmlId::ChapProcessPrivate)?;
                    chap_process_private.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapProcessCommand => {
                    let (val, read) = ChapProcessCommand::read_body(r, size)?;
                    chap_process_command.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapProcess'", id))?,
            }
            index += 1;
        }

        if chap_process_codec_id.len() == 0 { chap_process_codec_id.push_back(Ebml::new(0)); }
        if chap_process_codec_id.len() != 1 { Err(anyhow::anyhow!("One element 'ChapProcessCodecId' must be in 'ChapProcess'. Found {}", chap_process_codec_id.len()))? }
        let chap_process_codec_id = chap_process_codec_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapProcessCodecId' doesn't exist in 'ChapProcess'"))?;
        if chap_process_private.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapProcessPrivate' in 'ChapProcess' possible. Found {}", chap_process_private.len()))? }
        let chap_process_private = chap_process_private.pop_front();
        let chap_process_command = Vec::from(chap_process_command);

        Ok((Self{
            size,

            chap_process_codec_id,
            chap_process_private,
            chap_process_command,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ChapProcess {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ChapProcess { return Err(anyhow::anyhow!("ChapProcess not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapProcess' unknown data size is not allowed")),
        };
        let mut chap_process_codec_id: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chap_process_private: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();
        let mut chap_process_command: VecDeque<Ebml<ChapProcessCommand>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapProcessCodecId => {
                    let size = size.try_sized(EbmlId::ChapProcessCodecId)?;
                    chap_process_codec_id.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapProcessPrivate => {
                    let size = size.try_sized(EbmlId::ChapProcessPrivate)?;
                    chap_process_private.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapProcessCommand => {
                    let (val, read) = ChapProcessCommand::read_body(r, size).await?;
                    chap_process_command.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapProcess'", id))?,
            }
            index += 1;
        }

        if chap_process_codec_id.len() == 0 { chap_process_codec_id.push_back(Ebml::new(0)); }
        if chap_process_codec_id.len() != 1 { Err(anyhow::anyhow!("One element 'ChapProcessCodecId' must be in 'ChapProcess'. Found {}", chap_process_codec_id.len()))? }
        let chap_process_codec_id = chap_process_codec_id.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapProcessCodecId' doesn't exist in 'ChapProcess'"))?;
        if chap_process_private.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'ChapProcessPrivate' in 'ChapProcess' possible. Found {}", chap_process_private.len()))? }
        let chap_process_private = chap_process_private.pop_front();
        let chap_process_command = Vec::from(chap_process_command);

        Ok((Self{
            size,

            chap_process_codec_id,
            chap_process_private,
            chap_process_command,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for ChapProcessCommand {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::ChapProcessCommand { return Err(anyhow::anyhow!("ChapProcessCommand not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapProcessCommand' unknown data size is not allowed")),
        };
        let mut chap_process_time: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chap_process_data: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapProcessTime => {
                    let size = size.try_sized(EbmlId::ChapProcessTime)?;
                    chap_process_time.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::ChapProcessData => {
                    let size = size.try_sized(EbmlId::ChapProcessData)?;
                    chap_process_data.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapProcessCommand'", id))?,
            }
            index += 1;
        }

        if chap_process_time.len() != 1 { Err(anyhow::anyhow!("One element 'ChapProcessTime' must be in 'ChapProcessCommand'. Found {}", chap_process_time.len()))? }
        let chap_process_time = chap_process_time.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapProcessTime' doesn't exist in 'ChapProcessCommand'"))?;
        if chap_process_data.len() != 1 { Err(anyhow::anyhow!("One element 'ChapProcessData' must be in 'ChapProcessCommand'. Found {}", chap_process_data.len()))? }
        let chap_process_data = chap_process_data.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapProcessData' doesn't exist in 'ChapProcessCommand'"))?;

        Ok((Self{
            size,

            chap_process_time,
            chap_process_data,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for ChapProcessCommand {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::ChapProcessCommand { return Err(anyhow::anyhow!("ChapProcessCommand not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'ChapProcessCommand' unknown data size is not allowed")),
        };
        let mut chap_process_time: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut chap_process_data: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::ChapProcessTime => {
                    let size = size.try_sized(EbmlId::ChapProcessTime)?;
                    chap_process_time.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::ChapProcessData => {
                    let size = size.try_sized(EbmlId::ChapProcessData)?;
                    chap_process_data.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'ChapProcessCommand'", id))?,
            }
            index += 1;
        }

        if chap_process_time.len() != 1 { Err(anyhow::anyhow!("One element 'ChapProcessTime' must be in 'ChapProcessCommand'. Found {}", chap_process_time.len()))? }
        let chap_process_time = chap_process_time.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapProcessTime' doesn't exist in 'ChapProcessCommand'"))?;
        if chap_process_data.len() != 1 { Err(anyhow::anyhow!("One element 'ChapProcessData' must be in 'ChapProcessCommand'. Found {}", chap_process_data.len()))? }
        let chap_process_data = chap_process_data.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'ChapProcessData' doesn't exist in 'ChapProcessCommand'"))?;

        Ok((Self{
            size,

            chap_process_time,
            chap_process_data,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Tags {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Tags { return Err(anyhow::anyhow!("Tags not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Tags' unknown data size is not allowed")),
        };
        let mut tag: VecDeque<Ebml<Tag>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::Tag => {
                    let (val, read) = Tag::read_body(r, size)?;
                    tag.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Tags'", id))?,
            }
            index += 1;
        }

        let tag = Vec::from(tag);

        Ok((Self{
            size,

            tag,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Tags {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Tags { return Err(anyhow::anyhow!("Tags not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Tags' unknown data size is not allowed")),
        };
        let mut tag: VecDeque<Ebml<Tag>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::Tag => {
                    let (val, read) = Tag::read_body(r, size).await?;
                    tag.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Tags'", id))?,
            }
            index += 1;
        }

        let tag = Vec::from(tag);

        Ok((Self{
            size,

            tag,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Tag {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Tag { return Err(anyhow::anyhow!("Tag not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Tag' unknown data size is not allowed")),
        };
        let mut targets: VecDeque<Ebml<Targets>> = VecDeque::new();
        let mut simple_tag: VecDeque<Ebml<SimpleTag>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::Targets => {
                    let (val, read) = Targets::read_body(r, size)?;
                    targets.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::SimpleTag => {
                    let (val, read) = SimpleTag::read_body(r, size)?;
                    simple_tag.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Tag'", id))?,
            }
            index += 1;
        }

        if targets.len() != 1 { Err(anyhow::anyhow!("One element 'Targets' must be in 'Tag'. Found {}", targets.len()))? }
        let targets = targets.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Targets' doesn't exist in 'Tag'"))?;
        let simple_tag = Vec::from(simple_tag);

        Ok((Self{
            size,

            targets,
            simple_tag,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Tag {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Tag { return Err(anyhow::anyhow!("Tag not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Tag' unknown data size is not allowed")),
        };
        let mut targets: VecDeque<Ebml<Targets>> = VecDeque::new();
        let mut simple_tag: VecDeque<Ebml<SimpleTag>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::Targets => {
                    let (val, read) = Targets::read_body(r, size).await?;
                    targets.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                EbmlId::SimpleTag => {
                    let (val, read) = SimpleTag::read_body(r, size).await?;
                    simple_tag.push_back(Ebml::new_index(index, val));
                    all_size += read;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Tag'", id))?,
            }
            index += 1;
        }

        if targets.len() != 1 { Err(anyhow::anyhow!("One element 'Targets' must be in 'Tag'. Found {}", targets.len()))? }
        let targets = targets.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'Targets' doesn't exist in 'Tag'"))?;
        let simple_tag = Vec::from(simple_tag);

        Ok((Self{
            size,

            targets,
            simple_tag,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for Targets {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::Targets { return Err(anyhow::anyhow!("Targets not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Targets' unknown data size is not allowed")),
        };
        let mut target_type_value: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut target_type: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_track_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_chapter_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_attachment_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TargetTypeValue => {
                    let size = size.try_sized(EbmlId::TargetTypeValue)?;
                    target_type_value.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TargetType => {
                    let size = size.try_sized(EbmlId::TargetType)?;
                    target_type.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagTrackUid => {
                    let size = size.try_sized(EbmlId::TagTrackUid)?;
                    tag_track_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagEditionUid => {
                    let size = size.try_sized(EbmlId::TagEditionUid)?;
                    tag_edition_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagChapterUid => {
                    let size = size.try_sized(EbmlId::TagChapterUid)?;
                    tag_chapter_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagAttachmentUid => {
                    let size = size.try_sized(EbmlId::TagAttachmentUid)?;
                    tag_attachment_uid.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Targets'", id))?,
            }
            index += 1;
        }

        if target_type_value.len() == 0 { target_type_value.push_back(Ebml::new(50)); }
        if target_type_value.len() != 1 { Err(anyhow::anyhow!("One element 'TargetTypeValue' must be in 'Targets'. Found {}", target_type_value.len()))? }
        let target_type_value = target_type_value.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TargetTypeValue' doesn't exist in 'Targets'"))?;
        if target_type.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TargetType' in 'Targets' possible. Found {}", target_type.len()))? }
        let target_type = target_type.pop_front();
        let tag_track_uid = Vec::from(tag_track_uid);
        let tag_edition_uid = Vec::from(tag_edition_uid);
        let tag_chapter_uid = Vec::from(tag_chapter_uid);
        let tag_attachment_uid = Vec::from(tag_attachment_uid);

        Ok((Self{
            size,

            target_type_value,
            target_type,
            tag_track_uid,
            tag_edition_uid,
            tag_chapter_uid,
            tag_attachment_uid,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for Targets {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::Targets { return Err(anyhow::anyhow!("Targets not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'Targets' unknown data size is not allowed")),
        };
        let mut target_type_value: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut target_type: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_track_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_edition_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_chapter_uid: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_attachment_uid: VecDeque<Ebml<u64>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TargetTypeValue => {
                    let size = size.try_sized(EbmlId::TargetTypeValue)?;
                    target_type_value.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TargetType => {
                    let size = size.try_sized(EbmlId::TargetType)?;
                    target_type.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagTrackUid => {
                    let size = size.try_sized(EbmlId::TagTrackUid)?;
                    tag_track_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagEditionUid => {
                    let size = size.try_sized(EbmlId::TagEditionUid)?;
                    tag_edition_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagChapterUid => {
                    let size = size.try_sized(EbmlId::TagChapterUid)?;
                    tag_chapter_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagAttachmentUid => {
                    let size = size.try_sized(EbmlId::TagAttachmentUid)?;
                    tag_attachment_uid.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'Targets'", id))?,
            }
            index += 1;
        }

        if target_type_value.len() == 0 { target_type_value.push_back(Ebml::new(50)); }
        if target_type_value.len() != 1 { Err(anyhow::anyhow!("One element 'TargetTypeValue' must be in 'Targets'. Found {}", target_type_value.len()))? }
        let target_type_value = target_type_value.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TargetTypeValue' doesn't exist in 'Targets'"))?;
        if target_type.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TargetType' in 'Targets' possible. Found {}", target_type.len()))? }
        let target_type = target_type.pop_front();
        let tag_track_uid = Vec::from(tag_track_uid);
        let tag_edition_uid = Vec::from(tag_edition_uid);
        let tag_chapter_uid = Vec::from(tag_chapter_uid);
        let tag_attachment_uid = Vec::from(tag_attachment_uid);

        Ok((Self{
            size,

            target_type_value,
            target_type,
            tag_track_uid,
            tag_edition_uid,
            tag_chapter_uid,
            tag_attachment_uid,
        }, all_size))
    }
}


impl<R: std::io::Read> super::ElementReadBlocking<R> for SimpleTag {
    fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r)?;
        let (element, body_len) = Self::read_body(r, size)?;
        Ok((element, header_len + body_len))
    }
    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = blocking::read_element_id_size(r)?;
        if id != EbmlId::SimpleTag { return Err(anyhow::anyhow!("SimpleTag not found")); }
        Ok((size, header_len as usize))
    }

    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'SimpleTag' unknown data size is not allowed")),
        };
        let mut tag_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_language: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_language_bcp_47: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_default: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_default_bogus: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_string: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_binary: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = blocking::read_element_id_size(r)?;
            all_size += header_len as usize;
            match id {
                EbmlId::TagName => {
                    let size = size.try_sized(EbmlId::TagName)?;
                    tag_name.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagLanguage => {
                    let size = size.try_sized(EbmlId::TagLanguage)?;
                    tag_language.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagLanguageBcp47 => {
                    let size = size.try_sized(EbmlId::TagLanguageBcp47)?;
                    tag_language_bcp_47.push_back(Ebml::new_index(index, blocking::read_string(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagDefault => {
                    let size = size.try_sized(EbmlId::TagDefault)?;
                    tag_default.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagDefaultBogus => {
                    let size = size.try_sized(EbmlId::TagDefaultBogus)?;
                    tag_default_bogus.push_back(Ebml::new_index(index, blocking::read_uint(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagString => {
                    let size = size.try_sized(EbmlId::TagString)?;
                    tag_string.push_back(Ebml::new_index(index, blocking::read_utf8(r, size)?));
                    all_size += size as usize;
                },
                EbmlId::TagBinary => {
                    let size = size.try_sized(EbmlId::TagBinary)?;
                    tag_binary.push_back(Ebml::new_index(index, blocking::read_bin(r, size)?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'SimpleTag'", id))?,
            }
            index += 1;
        }

        if tag_name.len() != 1 { Err(anyhow::anyhow!("One element 'TagName' must be in 'SimpleTag'. Found {}", tag_name.len()))? }
        let tag_name = tag_name.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TagName' doesn't exist in 'SimpleTag'"))?;
        if tag_language.len() == 0 { tag_language.push_back(Ebml::new("und".to_string())); }
        if tag_language.len() != 1 { Err(anyhow::anyhow!("One element 'TagLanguage' must be in 'SimpleTag'. Found {}", tag_language.len()))? }
        let tag_language = tag_language.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TagLanguage' doesn't exist in 'SimpleTag'"))?;
        if tag_language_bcp_47.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TagLanguageBcp47' in 'SimpleTag' possible. Found {}", tag_language_bcp_47.len()))? }
        let tag_language_bcp_47 = tag_language_bcp_47.pop_front();
        if tag_default.len() == 0 { tag_default.push_back(Ebml::new(1)); }
        if tag_default.len() != 1 { Err(anyhow::anyhow!("One element 'TagDefault' must be in 'SimpleTag'. Found {}", tag_default.len()))? }
        let tag_default = tag_default.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TagDefault' doesn't exist in 'SimpleTag'"))?;
        if tag_default_bogus.len() == 0 { tag_default_bogus.push_back(Ebml::new(1)); }
        if tag_default_bogus.len() != 1 { Err(anyhow::anyhow!("One element 'TagDefaultBogus' must be in 'SimpleTag'. Found {}", tag_default_bogus.len()))? }
        let tag_default_bogus = tag_default_bogus.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TagDefaultBogus' doesn't exist in 'SimpleTag'"))?;
        if tag_string.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TagString' in 'SimpleTag' possible. Found {}", tag_string.len()))? }
        let tag_string = tag_string.pop_front();
        if tag_binary.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TagBinary' in 'SimpleTag' possible. Found {}", tag_binary.len()))? }
        let tag_binary = tag_binary.pop_front();

        Ok((Self{
            size,

            tag_name,
            tag_language,
            tag_language_bcp_47,
            tag_default,
            tag_default_bogus,
            tag_string,
            tag_binary,
        }, all_size))
    }
}
#[async_trait::async_trait]
impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for SimpleTag {
    async fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {
        let (size, header_len) = Self::read_header(r).await?;
        let (element, body_len) = Self::read_body(r, size).await?;
        Ok((element, header_len + body_len))
    }
    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {
        let (id, size, header_len) = async_::read_element_id_size(r).await?;
        if id != EbmlId::SimpleTag { return Err(anyhow::anyhow!("SimpleTag not found")); }
        Ok((size, header_len as usize))
    }

    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {
        let size = match size {
            ElementSize::Sized(size) => size,
            ElementSize::Unknown(_) => return Err(anyhow::anyhow!("Element ID 'SimpleTag' unknown data size is not allowed")),
        };
        let mut tag_name: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_language: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_language_bcp_47: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_default: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_default_bogus: VecDeque<Ebml<u64>> = VecDeque::new();
        let mut tag_string: VecDeque<Ebml<String>> = VecDeque::new();
        let mut tag_binary: VecDeque<Ebml<Vec<u8>>> = VecDeque::new();

        let mut index = 0;
        let mut all_size = 0;
        loop {
            if all_size >= size as usize { break }
            let (id, size, header_len) = async_::read_element_id_size(r).await?;
            all_size += header_len as usize;
            match id {
                EbmlId::TagName => {
                    let size = size.try_sized(EbmlId::TagName)?;
                    tag_name.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagLanguage => {
                    let size = size.try_sized(EbmlId::TagLanguage)?;
                    tag_language.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagLanguageBcp47 => {
                    let size = size.try_sized(EbmlId::TagLanguageBcp47)?;
                    tag_language_bcp_47.push_back(Ebml::new_index(index, async_::read_string(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagDefault => {
                    let size = size.try_sized(EbmlId::TagDefault)?;
                    tag_default.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagDefaultBogus => {
                    let size = size.try_sized(EbmlId::TagDefaultBogus)?;
                    tag_default_bogus.push_back(Ebml::new_index(index, async_::read_uint(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagString => {
                    let size = size.try_sized(EbmlId::TagString)?;
                    tag_string.push_back(Ebml::new_index(index, async_::read_utf8(r, size).await?));
                    all_size += size as usize;
                },
                EbmlId::TagBinary => {
                    let size = size.try_sized(EbmlId::TagBinary)?;
                    tag_binary.push_back(Ebml::new_index(index, async_::read_bin(r, size).await?));
                    all_size += size as usize;
                },
                id => Err(anyhow::anyhow!("unexpected element id '{:?}' in 'SimpleTag'", id))?,
            }
            index += 1;
        }

        if tag_name.len() != 1 { Err(anyhow::anyhow!("One element 'TagName' must be in 'SimpleTag'. Found {}", tag_name.len()))? }
        let tag_name = tag_name.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TagName' doesn't exist in 'SimpleTag'"))?;
        if tag_language.len() == 0 { tag_language.push_back(Ebml::new("und".to_string())); }
        if tag_language.len() != 1 { Err(anyhow::anyhow!("One element 'TagLanguage' must be in 'SimpleTag'. Found {}", tag_language.len()))? }
        let tag_language = tag_language.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TagLanguage' doesn't exist in 'SimpleTag'"))?;
        if tag_language_bcp_47.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TagLanguageBcp47' in 'SimpleTag' possible. Found {}", tag_language_bcp_47.len()))? }
        let tag_language_bcp_47 = tag_language_bcp_47.pop_front();
        if tag_default.len() == 0 { tag_default.push_back(Ebml::new(1)); }
        if tag_default.len() != 1 { Err(anyhow::anyhow!("One element 'TagDefault' must be in 'SimpleTag'. Found {}", tag_default.len()))? }
        let tag_default = tag_default.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TagDefault' doesn't exist in 'SimpleTag'"))?;
        if tag_default_bogus.len() == 0 { tag_default_bogus.push_back(Ebml::new(1)); }
        if tag_default_bogus.len() != 1 { Err(anyhow::anyhow!("One element 'TagDefaultBogus' must be in 'SimpleTag'. Found {}", tag_default_bogus.len()))? }
        let tag_default_bogus = tag_default_bogus.pop_front().ok_or_else(|| anyhow::anyhow!("Required element 'TagDefaultBogus' doesn't exist in 'SimpleTag'"))?;
        if tag_string.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TagString' in 'SimpleTag' possible. Found {}", tag_string.len()))? }
        let tag_string = tag_string.pop_front();
        if tag_binary.len() > 1 { Err(anyhow::anyhow!("Only zero or one element 'TagBinary' in 'SimpleTag' possible. Found {}", tag_binary.len()))? }
        let tag_binary = tag_binary.pop_front();

        Ok((Self{
            size,

            tag_name,
            tag_language,
            tag_language_bcp_47,
            tag_default,
            tag_default_bogus,
            tag_string,
            tag_binary,
        }, all_size))
    }
}


