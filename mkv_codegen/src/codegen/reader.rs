use crate::parser::ebml;
use ebml::{TypeAttr, ElementType};
use super::to_async;

pub fn generate(ebml_matroska: &ebml::EBMLMatroska) -> Result<String, anyhow::Error> {
    let mut str = format!("");

    str += "\
/// The code was generated by codegen!

use std::collections::VecDeque;

use super::io::*;
use super::structs::*;
use super::ids::EbmlId;
use super::{Ebml, ElementSize};

";
    for struct_ in &ebml_matroska.sorted_strcuts() {
        str += &format!("impl<R: std::io::Read> super::ElementReadBlocking<R> for {} {{\n", struct_.type_name());
        str += &impl_read(struct_, false);
        str += &impl_read_header(struct_, false);
        str += &impl_read_body(struct_, false);
        str += "}\n";

        str += &format!("#[async_trait::async_trait]\n");
        str += &format!("impl<R: tokio::io::AsyncRead + Send + Unpin> super::ElementRead<R> for {} {{\n", struct_.type_name());
            str += &impl_read(struct_, true);
            str += &impl_read_header(struct_, true);
            str += &impl_read_body(struct_, true);
        str += "}\n";
        str += "\n";
        str += "\n";
    }
    Ok(str)
}

pub fn impl_read(_struct_: &Box<ebml::EBMLStruct>, async_: bool) -> String {
    let mut str = format!("");
    let async_key = if async_ { "async " } else { "" };
    str += &format!("    {async_key}fn read(r: &mut R) -> Result<(Self, usize), anyhow::Error> {{\n");
    let await_ = if async_ { ".await" } else { "" };
    str += &format!("        let (size, header_len) = Self::read_header(r){await_}?;\n");
    str += &format!("        let (element, body_len) = Self::read_body(r, size){await_}?;\n");
    str += &format!("        Ok((element, header_len + body_len))\n");
    str += &format!("    }}\n");
    str
}

pub fn impl_read_header(struct_: &Box<ebml::EBMLStruct>, async_: bool) -> String {
    let mut str = format!("");
    if async_ {
        str += &format!("    async fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {{\n");
    } else {
        str += &format!("    fn read_header(r: &mut R) -> Result<(ElementSize, usize), anyhow::Error> {{\n");
    }
    let to_async = |str: &str| if async_ {
        format!("async_::{str}.await")
    } else {
        format!("blocking::{str}")
    };
    str += &format!("        let (id, size, header_len) = {}?;\n", to_async("read_element_id_size(r)"));
    str += &format!("        if id != EbmlId::{} {{ return Err(anyhow::anyhow!(\"{} not found\")); }}\n", struct_.type_name(), struct_.type_name());
    str += &format!("        Ok((size, header_len as usize))\n");
    str += &format!("    }}\n");
    str += "\n";
    str
}

pub fn impl_read_body(struct_: &Box<ebml::EBMLStruct>, async_: bool) -> String {
    let mut str = format!("");
    if async_ {
        str += &format!("    async fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {{\n");
    } else {
        str += &format!("    fn read_body(r: &mut R, size: ElementSize) -> Result<(Self, usize), anyhow::Error> {{\n");
    }
    if !struct_.element.unknown_size_allowed {
        str += &format!("        let size = match size {{\n");
        str += &format!("            ElementSize::Sized(size) => size,\n");
        str += &format!("            ElementSize::Unknown(_) => return Err(anyhow::anyhow!(\"Element ID '{}' unknown data size is not allowed\")),\n", struct_.type_name());
        str += &format!("        }};\n");
    }
    for child in &struct_.children {
        let type_name = child.element.type_name();
        let type_name = child.element.type_.to_native(type_name);
        str += &format!("        let mut {}: VecDeque<Ebml<{}>> = VecDeque::new();\n", child.element.var_name(), type_name);
    }
    str += &format!("\n");
    str += &format!("        let mut index = 0;\n");
    str += &format!("        let mut all_size = 0;\n");

    str += &format!("        loop {{\n");
    if struct_.element.unknown_size_allowed {
        str += &format!("            if let ElementSize::Sized(size) = size {{ if all_size >= size as usize {{ break }} }}\n");
        str += &format!("            let (id, size, header_len) = {}?;\n", to_async(async_, "read_element_id_size(r)"));
        str += &format!("            all_size += header_len as usize;\n");
        str += &format!("            if let ElementSize::Unknown(_) = size {{ if id == EbmlId::{}  {{ break }} }}\n", struct_.type_name());
    } else {
        str += &format!("            if all_size >= size as usize {{ break }}\n");
        str += &format!("            let (id, size, header_len) = {}?;\n", to_async(async_, "read_element_id_size(r)"));
        str += &format!("            all_size += header_len as usize;\n");
    }

    str += &format!("            match id {{\n");
    for child in &struct_.children {
        let type_name = child.element.type_name();
        let read_code = read_native(async_, &child.element.type_, type_name);
        if child.element.unknown_size_allowed {
            str += &format!("                EbmlId::{} => {{\n", child.element.type_name());
            str += &format!("                    let (val, read) = {read_code}?; all_size += read;\n");
            str += &format!("                    {}.push_back(Ebml::new_index(index, val));\n", child.element.var_name());
            str += &format!("                }},\n");
        } else {
            str += &format!("                EbmlId::{} => {{\n", child.element.type_name());
            if child.element.type_ == ElementType::Struct {
                str += &format!("                    let (val, read) = {read_code}?;\n");
                str += &format!("                    {}.push_back(Ebml::new_index(index, val));\n", child.element.var_name());
                str += &format!("                    all_size += read;\n");
            } else {
                str += &format!("                    let size = size.try_sized(EbmlId::{})?;\n", child.element.type_name());
                str += &format!("                    {}.push_back(Ebml::new_index(index, {read_code}?));\n", child.element.var_name());
                str += &format!("                    all_size += size as usize;\n");
            }
            str += &format!("                }},\n");
        }
    }
    str += &format!("                id => Err(anyhow::anyhow!(\"unexpected element id '{{:?}}' in '{}'\", id))?,\n", struct_.type_name());
    str += &format!("            }}\n");
    str += &format!("            index += 1;\n");
    str += &format!("        }}\n");
    str += &format!("\n");
    for child in &struct_.children {
        match child.element.attr {
            TypeAttr::Optional => {
                str += &format!("        if {}.len() > 1 {{ Err(anyhow::anyhow!(\"Only zero or one element '{}' in '{}' possible. Found {{}}\", {}.len()))? }}\n",
                                child.element.var_name(),
                                child.element.type_name(),
                                struct_.type_name(),
                                child.element.var_name()
                );
                str += &format!("        let {} = {}.pop_front();\n", child.element.var_name(), child.element.var_name());
            },
            TypeAttr::Required => {
                if let Some(default) = &child.element.default {
                    let default = match child.element.type_ {
                        ElementType::UInteger => format!("{default}"),
                        ElementType::Integer => format!("{default}"),
                        ElementType::Float => format!("hexf::hexf64!(\"{default}\")"),
                        ElementType::String | ElementType::Utf8 => format!("\"{default}\".to_string()"),
                        ElementType::Binary => format!("{default}"),
                        ElementType::Date => format!("{default}"),
                        ElementType::Struct => format!("{default}"),
                    };
                    str += &format!("        if {}.len() == 0 {{ {}.push_back(Ebml::new({default})); }}\n", child.element.var_name(), child.element.var_name());
                }
                str += &format!("        if {}.len() != 1 {{ Err(anyhow::anyhow!(\"One element '{}' must be in '{}'. Found {{}}\", {}.len()))? }}\n",
                                child.element.var_name(),
                                child.element.type_name(),
                                struct_.type_name(),
                                child.element.var_name()
                );
                str += &format!("        let {} = {}.pop_front().ok_or_else(|| anyhow::anyhow!(\"Required element '{}' doesn't exist in '{}'\"))?;\n",
                                child.element.var_name(), child.element.var_name(),
                                child.element.type_name(),
                                struct_.type_name(),
                );
            },
            TypeAttr::Repeated => {
                str += &format!("        let {} = Vec::from({});\n", child.element.var_name(), child.element.var_name());
            },
        }
    }
    str += &format!("\n");
    str += &format!("        Ok((Self{{\n");
    str += &format!("            size,\n");
    str += "\n";
    for child in &struct_.children {
        str += &format!("            {},\n", child.element.var_name());
    }
    str += &format!("        }}, all_size))\n");
    str += &format!("    }}\n");
    str
}

pub fn read_native(async_: bool, type_: &ElementType, type_name: String) -> String {
    if async_ {
        let type_name = format!("{type_name}::read_body(r, size).await");
        match type_ {
            ElementType::UInteger => "async_::read_uint(r, size).await",
            ElementType::Integer => "async_::read_int(r, size).await",
            ElementType::Float => "async_::read_float(r, size).await",
            ElementType::String => "async_::read_string(r, size).await",
            ElementType::Utf8 => "async_::read_utf8(r, size).await",
            ElementType::Date => "async_::read_date(r, size).await",
            ElementType::Binary => "async_::read_bin(r, size).await",
            ElementType::Struct => type_name.as_str(),
        }.to_string()
    } else {
        let type_name = format!("{type_name}::read_body(r, size)");
        match type_ {
            ElementType::UInteger => "blocking::read_uint(r, size)",
            ElementType::Integer => "blocking::read_int(r, size)",
            ElementType::Float => "blocking::read_float(r, size)",
            ElementType::String => "blocking::read_string(r, size)",
            ElementType::Utf8 => "blocking::read_utf8(r, size)",
            ElementType::Date => "blocking::read_date(r, size)",
            ElementType::Binary => "blocking::read_bin(r, size)",
            ElementType::Struct => type_name.as_str(),
        }.to_string()
    }
}